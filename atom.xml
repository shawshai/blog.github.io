<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>少帥的博客</title>
  
  <subtitle>Shaw Shai&#39;s Blog</subtitle>
  <link href="http://shawshai.cn/atom.xml" rel="self"/>
  
  <link href="http://shawshai.cn/"/>
  <updated>2023-04-17T07:38:37.926Z</updated>
  <id>http://shawshai.cn/</id>
  
  <author>
    <name>少帥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LQR 教程</title>
    <link href="http://shawshai.cn/2023/04/17/lqr-tutorial/"/>
    <id>http://shawshai.cn/2023/04/17/lqr-tutorial/</id>
    <published>2023-04-17T06:57:19.000Z</published>
    <updated>2023-04-17T07:38:37.926Z</updated>
    
    <content type="html"><![CDATA[<div align="center">本文为 MuJoCo 官方 LQR 教程的简单翻译. </div><span id="more"></span><p>原文链接如下:</p><p><a href="https://colab.research.google.com/github/deepmind/mujoco/blob/main/python/LQR.ipynb">https://colab.research.google.com/github/deepmind/mujoco/blob/main/python/LQR.ipynb</a></p><p>官方GitHub 链接为 <a href="https://github.com/deepmind/mujoco#readme">https://github.com/deepmind/mujoco</a>.</p><h2 id="安装-MuJoCo"><a href="#安装-MuJoCo" class="headerlink" title="安装 MuJoCo"></a><strong>安装 MuJoCo</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install mujoco</span><br></pre></td></tr></table></figure><h3 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a><strong>检查是否安装成功</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@title Check if installation was successful</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> files</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> distutils.util</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">if</span> subprocess.run(<span class="string">&#x27;nvidia-smi&#x27;</span>).returncode:</span><br><span class="line">  <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">      <span class="string">&#x27;Cannot communicate with GPU. &#x27;</span></span><br><span class="line">      <span class="string">&#x27;Make sure you are using a GPU Colab runtime. &#x27;</span></span><br><span class="line">      <span class="string">&#x27;Go to the Runtime menu and select Choose runtime type.&#x27;</span>)</span><br><span class="line"><span class="comment"># Configure MuJoCo to use the EGL rendering backend (requires GPU)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Setting environment variable to use GPU rendering:&#x27;</span>)</span><br><span class="line">%env MUJOCO_GL=egl</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Checking that the installation succeeded:&#x27;</span>)</span><br><span class="line">  <span class="keyword">import</span> mujoco</span><br><span class="line">  mujoco.MjModel.from_xml_string(<span class="string">&#x27;&lt;mujoco/&gt;&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  <span class="keyword">raise</span> e <span class="keyword">from</span> RuntimeError(</span><br><span class="line">      <span class="string">&#x27;Something went wrong during installation. Check the shell output above &#x27;</span></span><br><span class="line">      <span class="string">&#x27;for more information.\n&#x27;</span></span><br><span class="line">      <span class="string">&#x27;If using a hosted Colab runtime, make sure you enable GPU acceleration &#x27;</span></span><br><span class="line">      <span class="string">&#x27;by going to the Runtime menu and selecting &quot;Choose runtime type&quot;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Installation successful.&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="其它导入包与帮助函数"><a href="#其它导入包与帮助函数" class="headerlink" title="其它导入包与帮助函数"></a><strong>其它导入包与帮助函数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@title Other imports and helper functions</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Callable</span>, <span class="type">Optional</span>, <span class="type">Union</span>, <span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> scipy.linalg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Graphics and plotting.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Installing mediapy:&#x27;</span>)</span><br><span class="line">!command -v ffmpeg &gt;/dev/null || (apt update &amp;&amp; apt install -y ffmpeg)</span><br><span class="line">!pip install -q mediapy</span><br><span class="line"><span class="keyword">import</span> mediapy <span class="keyword">as</span> media</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># More legible printing from numpy.</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">3</span>, suppress=<span class="literal">True</span>, linewidth=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="加载与渲染标准人体模型"><a href="#加载与渲染标准人体模型" class="headerlink" title="加载与渲染标准人体模型"></a><strong>加载与渲染标准人体模型</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Getting MuJoCo humanoid XML description from GitHub:&#x27;</span>)</span><br><span class="line">!git clone https://github.com/deepmind/mujoco</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;mujoco/model/humanoid/humanoid.xml&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  xml = f.read()</span><br></pre></td></tr></table></figure><blockquote><p>Getting MuJoCo humanoid XML description from GitHub:<br>Cloning into ‘mujoco’…<br>remote: Enumerating objects: 7096, done.<br>remote: Counting objects: 100% (289/289), done.<br>remote: Compressing objects: 100% (153/153), done.<br>remote: Total 7096 (delta 145), reused 245 (delta 130), pack-reused 6807<br>Receiving objects: 100% (7096/7096), 42.89 MiB | 13.65 MiB/s, done.<br>Resolving deltas: 100% (5123/5123), done.</p></blockquote><p>XML用于实例化 <code>MjModel</code>. 给定模型，我们可以创建一个 <code>MjData</code> 来保存仿真状态, 以及上面定义的 <code>Renderer</code> 类的实例.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = mujoco.MjModel.from_xml_string(xml)</span><br><span class="line">data = mujoco.MjData(model)</span><br><span class="line">renderer = mujoco.Renderer(model)</span><br></pre></td></tr></table></figure><p><code>data</code> 对象的状态为默认配置. 让我们调用正向动力学来填充所有的派生的量(如几何体的世界坐标), 更新场景并渲染它:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">renderer.update_scene(data)</span><br><span class="line">media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/17/lqr-tutorial/0.png" class="" title="humanoid"></div><p>该模型带有一些内置的“关键帧”, 这些关键帧保存了仿真状态.</p><p>可以用 <code>mj_resetDataKeyframe</code> 来加载它们, 让我们看看它们长什么样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">range</span>(model.nkey):</span><br><span class="line">  mujoco.mj_resetDataKeyframe(model, data, key)</span><br><span class="line">  mujoco.mj_forward(model, data)</span><br><span class="line">  renderer.update_scene(data)</span><br><span class="line">  media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/17/lqr-tutorial/1.png" class="" title="kframe1"></div><div style="width:50%;margin:auto"><img src="/2023/04/17/lqr-tutorial/2.png" class="" title="kframe2"></div><p>现在让我们物理仿真并渲染来制作一个视频.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DURATION  = <span class="number">3</span>   <span class="comment"># seconds</span></span><br><span class="line">FRAMERATE = <span class="number">60</span>  <span class="comment"># Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize to the standing-on-one-leg pose.</span></span><br><span class="line">mujoco.mj_resetDataKeyframe(model, data, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">frames = []</span><br><span class="line"><span class="keyword">while</span> data.time &lt; DURATION:</span><br><span class="line">  <span class="comment"># Step the simulation.</span></span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Render and save frames.</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(frames) &lt; data.time * FRAMERATE:</span><br><span class="line">    renderer.update_scene(data)</span><br><span class="line">    pixels = renderer.render()</span><br><span class="line">    frames.append(pixels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display video.</span></span><br><span class="line">media.show_video(frames, fps=FRAMERATE)</span><br></pre></td></tr></table></figure><video controls >     <source src="fall.mp4" type="video/mp4"></video><p>该模型定义了内置的力矩执行器, 我们可以通过设置 <code>data.ctrl</code> 向量来驱动人体模型关节. 让我们看看如果引入噪声会发生什么.</p><p>这里, 我们使用一个自定义摄像机来跟踪人体模型的质心.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DURATION  = <span class="number">3</span>   <span class="comment"># seconds</span></span><br><span class="line">FRAMERATE = <span class="number">60</span>  <span class="comment"># Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a new camera, move it to a closer distance.</span></span><br><span class="line">camera = mujoco.MjvCamera()</span><br><span class="line">mujoco.mjv_defaultFreeCamera(model, camera)</span><br><span class="line">camera.distance = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">mujoco.mj_resetDataKeyframe(model, data, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">frames = []</span><br><span class="line"><span class="keyword">while</span> data.time &lt; DURATION:</span><br><span class="line">  <span class="comment"># Set control vector.</span></span><br><span class="line">  data.ctrl = np.random.randn(model.nu)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Step the simulation.</span></span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Render and save frames.</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(frames) &lt; data.time * FRAMERATE:</span><br><span class="line">    <span class="comment"># Set the lookat point to the humanoid&#x27;s center of mass.</span></span><br><span class="line">    camera.lookat = data.body(<span class="string">&#x27;torso&#x27;</span>).subtree_com</span><br><span class="line"></span><br><span class="line">    renderer.update_scene(data, camera)</span><br><span class="line">    pixels = renderer.render()</span><br><span class="line">    frames.append(pixels)</span><br><span class="line"></span><br><span class="line">media.show_video(frames, fps=FRAMERATE)</span><br></pre></td></tr></table></figure><video controls >     <source src="noise.mp4" type="video/mp4"></video><h2 id="稳定的单腿站立"><a href="#稳定的单腿站立" class="headerlink" title="稳定的单腿站立"></a><strong>稳定的单腿站立</strong></h2><p>显然这个初始姿态是不稳定的. 我们将尝试使用 <a href="https://en.wikipedia.org/wiki/Linear%E2%80%93quadratic_regulator">Linear Quadratic Regulator</a> 找到一个稳定的控制策略.</p><h3 id="LQR-理论回顾"><a href="#LQR-理论回顾" class="headerlink" title="LQR 理论回顾"></a><strong>LQR 理论回顾</strong></h3><p>这个理论是由 Rudolph Kalman 在20世纪60年代提出的, 网上有很多解释这个理论的资源, 但我们只提供一个简单的概述.</p><p>给定一个状态 $x$ 和控制 $u$ 为线性的动力系统,</p><p>$$<br>x_{t+h}=Ax_t+Bu_t<br>$$</p><p>如果系统满足一个可控性条件, 就有可能以最佳方式达到稳定(驱动 $x$ 到 $0$), 如下所示. 使用两个对称正定矩阵 $Q$ 和 $R$ 定义状态和控制上的二次代价函数 $J(x,u)$:</p><p>$$<br>J(x,u)=x^TQx+u^TRu<br>$$</p><p>Cost-to-go 函数 $V^\pi(x_0)$, 也称为值函数, 是未来成本的总和, 让状态从 $x_0$ 开始, 并根据动力学推演, 同时使用控制策略 $u=\pi(x)$:</p><p>$$<br>V^\pi(x_0)=\sum_{t=0}^\infty J(x_t,\pi(x_t))<br>$$</p><p>Kalman 的中心结论现在可以表述了. 在所有可能的控制策略中, 使得值函数最小化的最优控制策略是线性的</p><p>$$<br>\pi^*(x)=\arg\min_\pi V^\pi(x)=-Kx<br>$$</p><p>以及最优的值函数为二次的</p><p>$$<br>V^*(x)=\min_\pi V^\pi(x)=x^TPx<br>$$</p><p>矩阵 $P$ 满足 Riccati 方程</p><p>$$<br>P=Q+A^TPA-A^TPB(R+B^TPB)^{-1}B^TPA<br>$$</p><p>其与控制增益矩阵 $K$ 的关系为</p><p>$$<br>K=(R+B^TPB)^{-1}B^TPA<br>$$</p><h3 id="理解线性化设定值"><a href="#理解线性化设定值" class="headerlink" title="理解线性化设定值"></a><strong>理解线性化设定值</strong></h3><p>当然我们的人体模型仿真绝不是线性的. 但是, 当 MuJoCo 的 <code>mj_step</code> 函数计算一些非线性动力学方程 $x_{t+h}=f(x_t,u_t)$ 时, 我们可以在任何状态-控制对附近来线性化这个函数. 简记下一个状态为 $y=x_{t+h}$, 当前状态为 $x=x_t$ 以及当前控制为 $u=u_t$, 并使用 $\delta$ 表示“微小变化”, 我们可以这样表示</p><p>$$<br>\delta y=\frac{\partial f}{\partial x}\delta x+\frac{\partial f}{\partial u}\delta u<br>$$</p><p>换句话说, 偏导数矩阵描述了对 $x$ 和 $u$ 的扰动和对 $y$ 的变化之间的线性关系. 与上述理论相比, 当考虑线性化动力系统时, 我们可以用转换矩阵 $A$ 和 $B$ 来表示偏导数(雅可比矩阵)矩阵:</p><p>$$<br>A=\frac{\partial f}{\partial x} ~~~~~~ B=\frac{\partial f}{\partial u}<br>$$</p><p>为了进行线性化, 我们需要选择一些设定值 $x$ 和 $u$, 在它们附近进行线性化. 我们已经知道了 $x$, 这是我们单腿站立的初始姿势. 但是 $u$ 呢? 我们如何找到可以在其附近进行线性化的“最佳”控制值?</p><p>答案是反向动力学.</p><h3 id="通过反向动力学寻找控制设定值"><a href="#通过反向动力学寻找控制设定值" class="headerlink" title="通过反向动力学寻找控制设定值"></a><strong>通过反向动力学寻找控制设定值</strong></h3><p>MuJoCo 的前向动力学函数 <code>mj_forward</code>, 我们在上面使用它来传播派生量, 计算给定状态和系统中的所有力时的加速度, 其中一些是由执行器创建的.</p><p>反向动力学函数将加速度作为输入, 并计算产生加速度所需的力. 独特的是, MuJoCo 的<a href="https://doi.org/10.1109/ICRA.2014.6907751">快速反向动力学</a>考虑到所有的约束, 包括接触. 让我们看看它是如何工作的.</p><p>我们将在目标位置的设定值处调用前向动力学, 在 <code>data.qacc</code> 中设置加速度为 0, 并调用逆动力学:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mujoco.mj_resetDataKeyframe(model, data, <span class="number">1</span>)</span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">data.qacc = <span class="number">0</span>  <span class="comment"># Assert that there is no the acceleration.</span></span><br><span class="line">mujoco.mj_inverse(model, data)</span><br><span class="line"><span class="built_in">print</span>(data.qfrc_inverse)</span><br></pre></td></tr></table></figure><blockquote><p>[  0.      0.    275.879 -33.186   4.995  -6.688  -4.305   3.693 -15.451 -10.906   0.412  -1.613 -9.793  -2.312  -0.366  -5.913  -0.417  -1.914   5.759   2.665  -0.202  -5.755   0.994   1.141 -1.987   3.821   1.151]</p></blockquote><p>检查由反向动力学得到的力, 我们看到一些相当令人不安的东西. 有一个非常大的力作用在第三自由度(DoF), 即根关节的垂直运动自由度.</p><p>这意味着, 为了解释加速度为零的设定, 反向动力学必须创造一个直接作用于根关节的“神奇”的力. 让我们看看当我们将人体模型上下移动 1mm 时, 这个力是如何变化的, 增量为 1μm:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">height_offsets = np.linspace(-<span class="number">0.001</span>, <span class="number">0.001</span>, <span class="number">2001</span>)</span><br><span class="line">vertical_forces = []</span><br><span class="line"><span class="keyword">for</span> offset <span class="keyword">in</span> height_offsets:</span><br><span class="line">  mujoco.mj_resetDataKeyframe(model, data, <span class="number">1</span>)</span><br><span class="line">  mujoco.mj_forward(model, data)</span><br><span class="line">  data.qacc = <span class="number">0</span></span><br><span class="line">  <span class="comment"># Offset the height by `offset`.</span></span><br><span class="line">  data.qpos[<span class="number">2</span>] += offset</span><br><span class="line">  mujoco.mj_inverse(model, data)</span><br><span class="line">  vertical_forces.append(data.qfrc_inverse[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find the height-offset at which the vertical force is smallest.</span></span><br><span class="line">idx = np.argmin(np.<span class="built_in">abs</span>(vertical_forces))</span><br><span class="line">best_offset = height_offsets[idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the relationship.</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(height_offsets * <span class="number">1000</span>, vertical_forces, linewidth=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Red vertical line at offset corresponding to smallest vertical force.</span></span><br><span class="line">plt.axvline(x=best_offset*<span class="number">1000</span>, color=<span class="string">&#x27;red&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"><span class="comment"># Green horizontal line at the humanoid&#x27;s weight.</span></span><br><span class="line">weight = model.body_subtreemass[<span class="number">1</span>]*np.linalg.norm(model.opt.gravity)</span><br><span class="line">plt.axhline(y=weight, color=<span class="string">&#x27;green&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Height offset (mm)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Vertical force (N)&#x27;</span>)</span><br><span class="line">plt.grid(which=<span class="string">&#x27;major&#x27;</span>, color=<span class="string">&#x27;#DDDDDD&#x27;</span>, linewidth=<span class="number">0.8</span>)</span><br><span class="line">plt.grid(which=<span class="string">&#x27;minor&#x27;</span>, color=<span class="string">&#x27;#EEEEEE&#x27;</span>, linestyle=<span class="string">&#x27;:&#x27;</span>, linewidth=<span class="number">0.5</span>)</span><br><span class="line">plt.minorticks_on()</span><br><span class="line">plt.title(<span class="string">f&#x27;Smallest vertical force &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;found at offset <span class="subst">&#123;best_offset*<span class="number">1000</span>:<span class="number">.4</span>f&#125;</span>mm.&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div style="width:70%;margin:auto"><img src="/2023/04/17/lqr-tutorial/3.png" class="" title="force"></div><p>在上面的图中, 我们可以看到由于脚的接触而产生的强非线性关系. 在左边, 当我们把人体模型推到地板上时, 唯一能解释它没有跳出地板的原因是一个巨大的外力把它往<strong>下</strong>推. 在右边, 当我们将人体模型移离地面时, 解释加速度为零的唯一方法是有一个力向<strong>上</strong>支撑着它, 我们可以清楚地看到脚离开地面的高度, 所需的力正好等于人体模型的重量(绿线), 并且在我们不断向上移动时保持不变.</p><p>在 -0.5mm 附近是完美的高度偏移量(红线), 在这里, 零垂直加速度可以完全用关节内力来解释, 而不需要借助“神奇的”外力. 让我们修正初始姿态的高度, 将其保存在 <code>qpos0</code> 中, 并再次通过反向动力学计算受力:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mujoco.mj_resetDataKeyframe(model, data, <span class="number">1</span>)</span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">data.qacc = <span class="number">0</span></span><br><span class="line">data.qpos[<span class="number">2</span>] += best_offset</span><br><span class="line">qpos0 = data.qpos.copy()  <span class="comment"># Save the position setpoint.</span></span><br><span class="line">mujoco.mj_inverse(model, data)</span><br><span class="line">qfrc0 = data.qfrc_inverse.copy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;desired forces:&#x27;</span>, qfrc0)</span><br></pre></td></tr></table></figure><blockquote><p>desired forces: [  0.      0.     -0.191  -3.447   0.222  -0.817   2.586  14.637 -18.64  -10.906   0.412  -1.613 -9.793  -2.312  -0.366 -23.755  -2.171  12.264  26.101  13.337  -0.113  -5.755   0.994   1.141 -1.987   3.821   1.151]</p></blockquote><p>好多了, 根关节上的力很小. 现在我们有了执行器可以合理地产生的力, 我们如何找到产生这些力的执行器值呢? 对于像人体模型这样的简单 <code>motor</code> 执行器, 我们可以简单地“除以”驱动力矩臂矩阵, 即乘以它的伪逆:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctrl0 = np.atleast_2d(qfrc0) @ np.linalg.pinv(data.actuator_moment)</span><br><span class="line">ctrl0 = ctrl0.flatten()  <span class="comment"># Save the ctrl setpoint.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;control setpoint:&#x27;</span>, ctrl0)</span><br></pre></td></tr></table></figure><blockquote><p>control setpoint: [ 0.366  0.065 -0.466 -0.273  0.01  -0.013 -0.122 -0.018 -0.116 -0.594 -0.054  0.102  0.326 -0.006 0.667 -0.288  0.05   0.029 -0.099  0.191  0.029]</p></blockquote><p>更精细的执行器将需要不同的方法来恢复 $\frac{\partial<del>\text{qfrc_actuator}}{\partial</del>\text{ctrl}}$, 而有限差分总是一个简单的选择.</p><p>让我们在前向动力学中应用这些控制, 并将它们产生的力与上面打印的期望力进行比较:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.ctrl = ctrl0</span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;actuator forces:&#x27;</span>, data.qfrc_actuator)</span><br></pre></td></tr></table></figure><blockquote><p>actuator forces: [  0.      0.      0.      0.      0.      0.      2.586  14.637 -18.64  -10.906   0.412  -1.613<br>-9.793  -2.312  -0.366 -23.755  -2.171  12.264  26.101  13.337  -0.113  -5.755   0.994   1.141<br>-1.987   3.821   1.151]</p></blockquote><p>由于人体模型是完全驱动的(除了根关节), 所需的力都在执行器的限制范围内, 我们可以看到所有内部关节的所需力完全匹配. 在根关节处还有一些不匹配，但是很小. 让我们看看当我们应用这些控制时的仿真效果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DURATION  = <span class="number">3</span>   <span class="comment"># seconds</span></span><br><span class="line">FRAMERATE = <span class="number">60</span>  <span class="comment"># Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the state and controls to their setpoints.</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line">data.qpos = qpos0</span><br><span class="line">data.ctrl = ctrl0</span><br><span class="line"></span><br><span class="line">frames = []</span><br><span class="line"><span class="keyword">while</span> data.time &lt; DURATION:</span><br><span class="line">  <span class="comment"># Step the simulation.</span></span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Render and save frames.</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(frames) &lt; data.time * FRAMERATE:</span><br><span class="line">    <span class="comment"># Set the lookat point to the humanoid&#x27;s center of mass.</span></span><br><span class="line">    camera.lookat = data.body(<span class="string">&#x27;torso&#x27;</span>).subtree_com</span><br><span class="line">    renderer.update_scene(data, camera)</span><br><span class="line">    pixels = renderer.render()</span><br><span class="line">    frames.append(pixels)</span><br><span class="line"></span><br><span class="line">media.show_video(frames, fps=FRAMERATE)</span><br></pre></td></tr></table></figure><video controls >     <source src="better.mp4" type="video/mp4"></video><p>与我们上面制作的完全被动的视频相比, 我们可以看到这是一个更好的控制设定值. 人形机器人仍然摔倒了, 但它试图稳定下来, 并成功了一小会儿.</p><h3 id="选择-Q-和-R-矩阵"><a href="#选择-Q-和-R-矩阵" class="headerlink" title="选择 $Q$ 和 $R$ 矩阵"></a><strong>选择 $Q$ 和 $R$ 矩阵</strong></h3><p>为了得到LQR反馈控制策略, 我们需要设计 $Q$ 和 $R$ 矩阵. 由于线性结构, 解对于两个矩阵的缩放是不变的, 所以在不失一般性的情况下, 我们可以选择 $R$ 为单位矩阵:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nu = model.nu  <span class="comment"># Alias for the number of actuators.</span></span><br><span class="line">R = np.eye(nu)</span><br></pre></td></tr></table></figure><p>$Q$ 的选择更为复杂. 我们将把它构造成两项的和.</p><p>首先, 是一个平衡成本, 使重心(CoM)保持在脚上. 为了描述它, 我们将使用运动学雅可比矩阵来映射关节空间和全局笛卡尔位置. MuJoCo 对这些进行了分析计算.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nv = model.nv  <span class="comment"># Shortcut for the number of DoFs.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the Jacobian for the root body (torso) CoM.</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line">data.qpos = qpos0</span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">jac_com = np.zeros((<span class="number">3</span>, nv))</span><br><span class="line">mujoco.mj_jacSubtreeCom(model, data, jac_com, model.body(<span class="string">&#x27;torso&#x27;</span>).<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the Jacobian for the left foot.</span></span><br><span class="line">jac_foot = np.zeros((<span class="number">3</span>, nv))</span><br><span class="line">mujoco.mj_jacBodyCom(model, data, jac_foot, <span class="literal">None</span>, model.body(<span class="string">&#x27;foot_left&#x27;</span>).<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">jac_diff = jac_com - jac_foot</span><br><span class="line">Qbalance = jac_diff.T @ jac_diff</span><br></pre></td></tr></table></figure><p>第二, 关节偏离其初始配置的成本, 对于不同的关节集合, 我们需要不同的系数:</p><ul><li>自由关节的系数将为 0, 因为 CoM 成本项已经考虑到了这一点.</li><li>左腿平衡所需要的关节, 即左腿关节和水平腹部关节, 应该保持非常接近他们的初始值.</li><li>所有其他关节的系数都应该小一些, 这样人体模型就能通过摆动手臂来保持平衡.</li></ul><p>我们求出所有这些关节集的指标.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get all joint names.</span></span><br><span class="line">joint_names = [model.joint(i).name <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(model.njnt)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get indices into relevant sets of joints.</span></span><br><span class="line">root_dofs = <span class="built_in">range</span>(<span class="number">6</span>)</span><br><span class="line">body_dofs = <span class="built_in">range</span>(<span class="number">6</span>, nv)</span><br><span class="line">abdomen_dofs = [</span><br><span class="line">    model.joint(name).dofadr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> joint_names</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;abdomen&#x27;</span> <span class="keyword">in</span> name</span><br><span class="line">    <span class="keyword">and</span> <span class="keyword">not</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">in</span> name</span><br><span class="line">]</span><br><span class="line">left_leg_dofs = [</span><br><span class="line">    model.joint(name).dofadr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> joint_names</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;left&#x27;</span> <span class="keyword">in</span> name</span><br><span class="line">    <span class="keyword">and</span> (<span class="string">&#x27;hip&#x27;</span> <span class="keyword">in</span> name <span class="keyword">or</span> <span class="string">&#x27;knee&#x27;</span> <span class="keyword">in</span> name <span class="keyword">or</span> <span class="string">&#x27;ankle&#x27;</span> <span class="keyword">in</span> name)</span><br><span class="line">    <span class="keyword">and</span> <span class="keyword">not</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">in</span> name</span><br><span class="line">]</span><br><span class="line">balance_dofs = abdomen_dofs + left_leg_dofs</span><br><span class="line">other_dofs = np.setdiff1d(body_dofs, balance_dofs)</span><br></pre></td></tr></table></figure><p>现在我们准备构造 $Q$ 矩阵. 注意, 平衡项的系数相当高. 这是由于3个不同的原因:</p><ul><li>这是我们最关心的事情. 平衡意味着保持重心在脚上.</li><li>我们对 CoM (相对于身体关节)的控制权限较少.</li><li>在平衡环境中, 长度单位“更大”. 如果膝盖弯曲 0.1 弧度(≈6°), 我们可能仍然可以恢复. 如果 CoM 的位置离脚的位置有 10cm 的距离, 我们很可能正在倒向地板.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cost coefficients.</span></span><br><span class="line">BALANCE_COST        = <span class="number">1000</span>  <span class="comment"># Balancing.</span></span><br><span class="line">BALANCE_JOINT_COST  = <span class="number">3</span>     <span class="comment"># Joints required for balancing.</span></span><br><span class="line">OTHER_JOINT_COST    = <span class="number">.3</span>    <span class="comment"># Other joints.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct the Qjoint matrix.</span></span><br><span class="line">Qjoint = np.eye(nv)</span><br><span class="line">Qjoint[root_dofs, root_dofs] *= <span class="number">0</span>  <span class="comment"># Don&#x27;t penalize free joint directly.</span></span><br><span class="line">Qjoint[balance_dofs, balance_dofs] *= BALANCE_JOINT_COST</span><br><span class="line">Qjoint[other_dofs, other_dofs] *= OTHER_JOINT_COST</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct the Q matrix for position DoFs.</span></span><br><span class="line">Qpos = BALANCE_COST * Qbalance + Qjoint</span><br><span class="line"></span><br><span class="line"><span class="comment"># No explicit penalty for velocities.</span></span><br><span class="line">Q = np.block([[Qpos, np.zeros((nv, nv))],</span><br><span class="line">              [np.zeros((nv, <span class="number">2</span>*nv))]])</span><br></pre></td></tr></table></figure><h3 id="计算-LQR-增益矩阵-K"><a href="#计算-LQR-增益矩阵-K" class="headerlink" title="计算 LQR 增益矩阵 $K$"></a>计算 LQR 增益矩阵 $K$</h3><p>在我们求解 LQR 控制器之前, 我们需要矩阵 $A$ 和 $B$. 这些是由 MuJoCo 的 <code>mjd_transitionFD</code> 函数计算的, 该函数使用有效的有限差分导数来计算它们, 利用可配置的计算管道来避免重新计算没有变化的量.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the initial state and control.</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line">data.ctrl = ctrl0</span><br><span class="line">data.qpos = qpos0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Allocate the A and B matrices, compute them.</span></span><br><span class="line">A = np.zeros((<span class="number">2</span>*nv, <span class="number">2</span>*nv))</span><br><span class="line">B = np.zeros((<span class="number">2</span>*nv, nu))</span><br><span class="line">epsilon = <span class="number">1e-6</span></span><br><span class="line">centered = <span class="literal">True</span></span><br><span class="line">mujoco.mjd_transitionFD(model, data, epsilon, centered, A, B, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>现在我们可以求解稳定控制器了. 我们将使用 <code>scipy</code> 的 <code>solve_discrete_are</code> 来求解 Riccati 方程, 并使用概述中描述的公式得到反馈增益矩阵.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Solve discrete Riccati equation.</span></span><br><span class="line">P = scipy.linalg.solve_discrete_are(A, B, Q, R)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the feedback gain matrix K.</span></span><br><span class="line">K = np.linalg.inv(R + B.T @ P @ B) @ B.T @ P @ A</span><br></pre></td></tr></table></figure><h3 id="稳定站立"><a href="#稳定站立" class="headerlink" title="稳定站立"></a><strong>稳定站立</strong></h3><p>现在我们可以试试稳定控制器.</p><p>注意, 为了应用我们的增益矩阵 $K$, 我们需要使用 <code>mj_differentiatePos</code> 来计算两个位置的差值. 这很重要, 因为根关节朝向是由长度为 4 的四元数给出的, 而两个四元数的差值(在切线空间中)是长度为 3 的. 在 MuJoCo 符号中, 位置(<code>qpos</code>)的大小为 <code>nq</code>, 而位置差(和速度)的大小为 <code>nv</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parameters.</span></span><br><span class="line">DURATION = <span class="number">5</span>          <span class="comment"># seconds</span></span><br><span class="line">FRAMERATE = <span class="number">60</span>        <span class="comment"># Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reset data, set initial pose.</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line">data.qpos = qpos0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Allocate position difference dq.</span></span><br><span class="line">dq = np.zeros(model.nv)</span><br><span class="line"></span><br><span class="line">frames = []</span><br><span class="line"><span class="keyword">while</span> data.time &lt; DURATION:</span><br><span class="line">  <span class="comment"># Get state difference dx.</span></span><br><span class="line">  mujoco.mj_differentiatePos(model, dq, <span class="number">1</span>, qpos0, data.qpos)</span><br><span class="line">  dx = np.hstack((dq, data.qvel)).T</span><br><span class="line"></span><br><span class="line">  <span class="comment"># LQR control law.</span></span><br><span class="line">  data.ctrl = ctrl0 - K @ dx</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Step the simulation.</span></span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Render and save frames.</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(frames) &lt; data.time * FRAMERATE:</span><br><span class="line">    renderer.update_scene(data)</span><br><span class="line">    pixels = renderer.render()</span><br><span class="line">    frames.append(pixels)</span><br><span class="line"></span><br><span class="line">media.show_video(frames, fps=FRAMERATE)</span><br></pre></td></tr></table></figure><video controls >     <source src="stable.mp4" type="video/mp4"></video><h3 id="最终视频"><a href="#最终视频" class="headerlink" title="最终视频"></a><strong>最终视频</strong></h3><p>上面的视频有点令人失望, 因为这个人体模型基本上是一动不动的. 让我们来解决这个问题, 并为我们的最终产品添加一些华丽的装饰:</p><ul><li>在 LQR 控制器上引入平滑的噪声, 使平衡动作更明显, 但不抖动.</li><li>为场景添加接触力可视化.</li><li>让摄像机平稳地绕着人体模型旋转.</li><li>实例化一个具有更高分辨率的新渲染器.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parameters.</span></span><br><span class="line">DURATION = <span class="number">12</span>         <span class="comment"># seconds</span></span><br><span class="line">FRAMERATE = <span class="number">60</span>        <span class="comment"># Hz</span></span><br><span class="line">TOTAL_ROTATION = <span class="number">15</span>   <span class="comment"># degrees</span></span><br><span class="line">CTRL_STD = <span class="number">0.05</span>       <span class="comment"># actuator units</span></span><br><span class="line">CTRL_RATE = <span class="number">0.8</span>       <span class="comment"># seconds</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make new camera, set distance.</span></span><br><span class="line">camera = mujoco.MjvCamera()</span><br><span class="line">mujoco.mjv_defaultFreeCamera(model, camera)</span><br><span class="line">camera.distance = <span class="number">2.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable contact force visualisation.</span></span><br><span class="line">scene_option = mujoco.MjvOption()</span><br><span class="line">scene_option.flags[mujoco.mjtVisFlag.mjVIS_CONTACTFORCE] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the scale of visualized contact forces to 1cm/N.</span></span><br><span class="line">model.vis.<span class="built_in">map</span>.force = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define smooth orbiting function.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unit_smooth</span>(<span class="params">normalised_time: <span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> - np.cos(normalised_time*<span class="number">2</span>*np.pi)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">azimuth</span>(<span class="params">time: <span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span> + unit_smooth(data.time/DURATION) * TOTAL_ROTATION</span><br><span class="line"></span><br><span class="line"><span class="comment"># Precompute some noise.</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">nsteps = <span class="built_in">int</span>(np.ceil(DURATION/model.opt.timestep))</span><br><span class="line">perturb = np.random.randn(nsteps, nu)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Smooth the noise.</span></span><br><span class="line">width = <span class="built_in">int</span>(nsteps * CTRL_RATE/DURATION)</span><br><span class="line">kernel = np.exp(-<span class="number">0.5</span>*np.linspace(-<span class="number">3</span>, <span class="number">3</span>, width)**<span class="number">2</span>)</span><br><span class="line">kernel /= np.linalg.norm(kernel)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nu):</span><br><span class="line">  perturb[:, i] = np.convolve(perturb[:, i], kernel, mode=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reset data, set initial pose.</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line">data.qpos = qpos0</span><br><span class="line"></span><br><span class="line"><span class="comment"># New renderer instance with higher resolution.</span></span><br><span class="line">renderer = mujoco.Renderer(model, width=<span class="number">1280</span>, height=<span class="number">720</span>)</span><br><span class="line"></span><br><span class="line">frames = []</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> data.time &lt; DURATION:</span><br><span class="line">  <span class="comment"># Get state difference dx.</span></span><br><span class="line">  mujoco.mj_differentiatePos(model, dq, <span class="number">1</span>, qpos0, data.qpos)</span><br><span class="line">  dx = np.hstack((dq, data.qvel)).T</span><br><span class="line"></span><br><span class="line">  <span class="comment"># LQR control law.</span></span><br><span class="line">  data.ctrl = ctrl0 - K @ dx</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Add perturbation, increment step.</span></span><br><span class="line">  data.ctrl += CTRL_STD*perturb[step]</span><br><span class="line">  step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Step the simulation.</span></span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Render and save frames.</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(frames) &lt; data.time * FRAMERATE:</span><br><span class="line">    camera.azimuth = azimuth(data.time)</span><br><span class="line">    renderer.update_scene(data, camera, scene_option)</span><br><span class="line">    pixels = renderer.render()</span><br><span class="line">    frames.append(pixels)</span><br><span class="line"></span><br><span class="line">media.show_video(frames, fps=FRAMERATE)</span><br></pre></td></tr></table></figure><video controls >     <source src="final.mp4" type="video/mp4"></video>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;center&quot;&gt;本文为 MuJoCo 官方 LQR 教程的简单翻译. &lt;/div&gt;</summary>
    
    
    
    
    <category term="lqr" scheme="http://shawshai.cn/tags/lqr/"/>
    
  </entry>
  
  <entry>
    <title>MuJoCo 教程</title>
    <link href="http://shawshai.cn/2023/04/13/mujoco-tutorial/"/>
    <id>http://shawshai.cn/2023/04/13/mujoco-tutorial/</id>
    <published>2023-04-13T11:30:42.000Z</published>
    <updated>2023-04-17T07:32:27.541Z</updated>
    
    <content type="html"><![CDATA[<div align="center">本文为 MuJoCo 官方教程的简单翻译. </div><span id="more"></span><p>原文链接如下:</p><p><a href="https://colab.research.google.com/github/deepmind/mujoco/blob/main/python/tutorial.ipynb">https://colab.research.google.com/github/deepmind/mujoco/blob/main/python/tutorial.ipynb</a></p><p>官方GitHub 链接为 <a href="https://github.com/deepmind/mujoco#readme">https://github.com/deepmind/mujoco</a>.</p><h2 id="安装-MuJoCo"><a href="#安装-MuJoCo" class="headerlink" title="安装 MuJoCo"></a><strong>安装 MuJoCo</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install mujoco</span><br></pre></td></tr></table></figure><h3 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a><strong>检查是否安装成功</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@title Check if installation was successful</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> files</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> distutils.util</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">if</span> subprocess.run(<span class="string">&#x27;nvidia-smi&#x27;</span>).returncode:</span><br><span class="line">  <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">      <span class="string">&#x27;Cannot communicate with GPU. &#x27;</span></span><br><span class="line">      <span class="string">&#x27;Make sure you are using a GPU Colab runtime. &#x27;</span></span><br><span class="line">      <span class="string">&#x27;Go to the Runtime menu and select Choose runtime type.&#x27;</span>)</span><br><span class="line"><span class="comment"># Configure MuJoCo to use the EGL rendering backend (requires GPU)</span></span><br><span class="line"><span class="comment"># use WGL for Windows</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Setting environment variable to use GPU rendering:&#x27;</span>)</span><br><span class="line">%env MUJOCO_GL=egl</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Checking that the installation succeeded:&#x27;</span>)</span><br><span class="line">  <span class="keyword">import</span> mujoco</span><br><span class="line">  mujoco.MjModel.from_xml_string(<span class="string">&#x27;&lt;mujoco/&gt;&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  <span class="keyword">raise</span> e <span class="keyword">from</span> RuntimeError(</span><br><span class="line">      <span class="string">&#x27;Something went wrong during installation. Check the shell output above &#x27;</span></span><br><span class="line">      <span class="string">&#x27;for more information.\n&#x27;</span></span><br><span class="line">      <span class="string">&#x27;If using a hosted Colab runtime, make sure you enable GPU acceleration &#x27;</span></span><br><span class="line">      <span class="string">&#x27;by going to the Runtime menu and selecting &quot;Choose runtime type&quot;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Installation successful.&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="导入相关图形和绘图包"><a href="#导入相关图形和绘图包" class="headerlink" title="导入相关图形和绘图包"></a><strong>导入相关图形和绘图包</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@title Import packages for plotting and creating graphics</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Callable</span>, NamedTuple, <span class="type">Optional</span>, <span class="type">Union</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Graphics and plotting.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Installing mediapy:&#x27;</span>)</span><br><span class="line">!command -v ffmpeg &gt;/dev/null || (apt update &amp;&amp; apt install -y ffmpeg)</span><br><span class="line">!pip install -q mediapy</span><br><span class="line"><span class="keyword">import</span> mediapy <span class="keyword">as</span> media</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># More legible printing from numpy.</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">3</span>, suppress=<span class="literal">True</span>, linewidth=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="MuJoCo-基础"><a href="#MuJoCo-基础" class="headerlink" title="MuJoCo 基础"></a><strong>MuJoCo 基础</strong></h2><p>我们从定义与读入一个简单的模型来开始:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;mujoco&gt;</span></span><br><span class="line"><span class="string">  &lt;worldbody&gt;</span></span><br><span class="line"><span class="string">    &lt;geom name=&quot;red_box&quot; type=&quot;box&quot; size=&quot;.2 .2 .2&quot; rgba=&quot;1 0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;geom name=&quot;green_sphere&quot; pos=&quot;.2 .2 .2&quot; size=&quot;.1&quot; rgba=&quot;0 1 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/worldbody&gt;</span></span><br><span class="line"><span class="string">&lt;/mujoco&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = mujoco.MjModel.from_xml_string(xml)</span><br></pre></td></tr></table></figure><p>这段 <code>xml</code> 代码依据 MuJoCo 的 <a href="http://www.mujoco.org/book/modeling.html">MJCF</a> 编写, 这是一种基于 <a href="https://en.wikipedia.org/wiki/XML#Key_terminology">XML</a> 的建模语言.</p><ul><li>唯一必需的元素为 <code>&lt;mujoco&gt;</code>. 最小的有效 MJCF 模型为 <code>&lt;mujoco/&gt;</code> , 这是一个完全空模型.</li><li>所有的物理元素放在 <code>&lt;worldbody&gt;</code> 中, 这始终为顶层物体并构成笛卡尔坐标系的全局原点.</li><li>我们在世界中定义两个几何体 <code>red_box</code> 和 <code>green_sphere</code>.</li><li><strong>问题:</strong> <code>red_box</code> 没有位置, the <code>green_sphere</code> 没有类型, 为什么?<ul><li><strong>答:</strong> MJCF 属性中有 <em>default values</em>. 默认位置为 <code>0 0 0</code>, 默认几何类型为 <code>sphere</code>. MJCF 语言在文档 <a href="https://mujoco.readthedocs.io/en/latest/XMLreference.html">XML Reference chapter</a> 中有相关解释.</li></ul></li></ul><p>方法 <code>from_xml_string()</code> 调用了模型编译器, 其创建了一个二进制 <code>mjModel</code> 实例.</p><h3 id="mjModel"><a href="#mjModel" class="headerlink" title="mjModel"></a><strong>mjModel</strong></h3><p>MuJoCo 中的 <code>mjModel</code>, 包含了模型描述, 比如所有均不随时间变化的量. <code>mjModel</code> 的完整描述可以在头文件 <a href="https://github.com/deepmind/mujoco/blob/main/include/mujoco/mjmodel.h">mjmodel.h</a> 的末尾找到. 注意, 头文件包含简短的有用的行内注释, 用于描述每个字段.</p><p>可以在模型 <code>mjModel</code> 找到一些量, 比如场景中的几何体数量<code>ngeom</code>,  以及它们各自的颜色 <code>geom_rgba</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.ngeom</span><br><span class="line">model.geom_rgba</span><br></pre></td></tr></table></figure><blockquote><p>2</p></blockquote><blockquote><p>array([[1., 0., 0., 1.],<br>       [0., 1., 0., 1.]], dtype=float32)</p></blockquote><h3 id="Named-access"><a href="#Named-access" class="headerlink" title="Named access"></a><strong>Named access</strong></h3><p>MuJoCo Python 的绑定使用名称提供了便捷的访问器, 在没有名称字符串的情况下调用 <code>model.geom()</code> 访问器会生成一个方便的错误提示, 告诉我们有效的名称是什么.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  model.geom()</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">  <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><blockquote><p>“Invalid name”. Valid names: [‘green_sphere’, ‘red_box’]</p></blockquote><p>调用命名访问器而不指定属性将告诉我们所有有效的属性是什么:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.geom(<span class="string">&#x27;green_sphere&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>&lt;_MjModelGeomViews<br>bodyid: array([0], dtype=int32)<br>conaffinity: array([1], dtype=int32)<br>condim: array([3], dtype=int32)<br>contype: array([1], dtype=int32)<br>dataid: array([-1], dtype=int32)<br>friction: array([1.   , 0.005, 0.   ])<br>gap: array([0.])<br>group: array([0], dtype=int32)<br>id: 1<br>margin: array([0.])<br>matid: array([-1], dtype=int32)<br>name: ‘green_sphere’<br>pos: array([0.2, 0.2, 0.2])<br>priority: array([0], dtype=int32)<br>quat: array([1., 0., 0., 0.])<br>rbound: array([0.1])<br>rgba: array([0., 1., 0., 1.], dtype=float32)<br>sameframe: array([0], dtype=uint8)<br>size: array([0.1, 0. , 0. ])<br>solimp: array([0.9  , 0.95 , 0.001, 0.5  , 2.   ])<br>solmix: array([1.])<br>solref: array([0.02, 1.  ])<br>type: array([2], dtype=int32)<br>user: array([], dtype=float64)</p></blockquote><p>让我们获取 <code>green_sphere</code> 的 rgba 值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.geom(<span class="string">&#x27;green_sphere&#x27;</span>).rgba</span><br></pre></td></tr></table></figure><blockquote><p>array([0., 1., 0., 1.], dtype=float32)</p></blockquote><p>这个函数是 MuJoCo 的 <a href="https://mujoco.readthedocs.io/en/latest/APIreference.html?highlight=mj_name2id#mj-name2id">mj_name2id</a> 函数的一个方便的快捷方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_GEOM, <span class="string">&#x27;green_sphere&#x27;</span>)</span><br><span class="line">model.geom_rgba[<span class="built_in">id</span>, :]</span><br></pre></td></tr></table></figure><blockquote><p>array([0., 1., 0., 1.], dtype=float32)</p></blockquote><p>类似地, 只读的 <code>id</code> 和<code>name</code> 属性可用于从 id 转换到 name 以及反之:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id of &quot;green_sphere&quot;: &#x27;</span>, model.geom(<span class="string">&#x27;green_sphere&#x27;</span>).<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;name of geom 1: &#x27;</span>, model.geom(<span class="number">1</span>).name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;name of body 0: &#x27;</span>, model.body(<span class="number">0</span>).name)</span><br></pre></td></tr></table></figure><blockquote><p>id of “green_sphere”:  1<br>name of geom 1:  green_sphere<br>name of body 0:  world</p></blockquote><p>注意, 第 0 个物体总是 <code>world</code>. 不能重命名.</p><p><code>id</code> 和 <code>name</code> 属性在 Python 推导式中很有用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[model.geom(i).name <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(model.ngeom)]</span><br></pre></td></tr></table></figure><blockquote><p>[‘red_box’, ‘green_sphere’]</p></blockquote><h3 id="mjData"><a href="#mjData" class="headerlink" title="mjData"></a><strong>mjData</strong></h3><p><code>mjData</code> 包含依赖于它的状态和数量. 状态由时间, 广义位置和广义速度组成, 分别为<code>data.time</code>, <code>data.qpos</code> 和 <code>data.qvel</code>. 为了创建一个新的 <code>mjData</code>，我们只需要 <code>mjModel</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = mujoco.MjData(model)</span><br></pre></td></tr></table></figure><p><code>mjData</code> 还包含状态函数, 例如世界坐标系中对象的笛卡尔位置. 两个几何体的 (x, y, z) 位置在 <code>data.geom_xpos</code> 中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(data.geom_xpos)</span><br></pre></td></tr></table></figure><blockquote><p>[[0. 0. 0.]<br> [0. 0. 0.]]</p></blockquote><p>等等, 为什么两个几何体都在原点? 绿色球体不是有位移吗? 答案是 <code>mjData</code> 中的派生量需要显式地传播(见下文). 在我们的例子中, 所需的最小函数是 <a href="https://mujoco.readthedocs.io/en/latest/APIreference.html#mj-kinematics">mj_kinematics</a>, 它计算所有对象(不包括相机和灯光)的全局笛卡尔姿态.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mujoco.mj_kinematics(model, data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;raw access:\n&#x27;</span>, data.geom_xpos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># MjData also supports named access:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nnamed access:\n&#x27;</span>, data.geom(<span class="string">&#x27;green_sphere&#x27;</span>).xpos)</span><br></pre></td></tr></table></figure><blockquote><p>raw access:<br> [[0.  0.  0. ]<br> [0.2 0.2 0.2]]</p><p>named access:<br>[0.2 0.2 0.2]</p></blockquote><h2 id="基本的渲染、模拟和动画"><a href="#基本的渲染、模拟和动画" class="headerlink" title="基本的渲染、模拟和动画"></a><strong>基本的渲染、模拟和动画</strong></h2><p>要实现渲染, 我们需要实例化一个 <code>Renderer</code> 对象并调用它的 <code>render</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;mujoco&gt;</span></span><br><span class="line"><span class="string">  &lt;worldbody&gt;</span></span><br><span class="line"><span class="string">    &lt;geom name=&quot;red_box&quot; type=&quot;box&quot; size=&quot;.2 .2 .2&quot; rgba=&quot;1 0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;geom name=&quot;green_sphere&quot; pos=&quot;.2 .2 .2&quot; size=&quot;.1&quot; rgba=&quot;0 1 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/worldbody&gt;</span></span><br><span class="line"><span class="string">&lt;/mujoco&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># Make model and data</span></span><br><span class="line">model = mujoco.MjModel.from_xml_string(xml)</span><br><span class="line">data = mujoco.MjData(model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make renderer, render and show the pixels</span></span><br><span class="line">renderer = mujoco.Renderer(model)</span><br><span class="line">media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/0.png" class="" title="black"></div><p>嗯… 为什么是黑色像素?</p><p><strong>答</strong>: 出于与上面相同的原因, 我们首先需要传播 <code>mjData</code> 中的值. 这次我们将调用 <a href="https://mujoco.readthedocs.io/en/latest/APIreference.html#mj-forward">mj_forward</a>, 它将调用整个管线, 直到计算加速度, 即, 它计算 $\dot{x}=f(x)$, 其中 $x$ 是状态. 这个函数所做的比我们实际需要的要多, 但是除非我们关心节省计算时间, 否则调用 <code>mj_forward</code> 是一个很好的实践, 因为这样我们就知道我们不会遗漏任何东西.</p><p>我们还需要更新 <code>mjvScene</code>, 这是一个由渲染器持有的描述可视化场景的对象. 我们稍后将看到场景可以包括不属于物理模型的可视化对象.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">renderer.update_scene(data)</span><br><span class="line"></span><br><span class="line">media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/1.png" class="" title="dark"></div><p>这是有效的, 但这张照片有点暗. 让我们添加一个灯光并重新渲染.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;mujoco&gt;</span></span><br><span class="line"><span class="string">  &lt;worldbody&gt;</span></span><br><span class="line"><span class="string">    &lt;light name=&quot;top&quot; pos=&quot;0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;geom name=&quot;red_box&quot; type=&quot;box&quot; size=&quot;.2 .2 .2&quot; rgba=&quot;1 0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;geom name=&quot;green_sphere&quot; pos=&quot;.2 .2 .2&quot; size=&quot;.1&quot; rgba=&quot;0 1 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/worldbody&gt;</span></span><br><span class="line"><span class="string">&lt;/mujoco&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = mujoco.MjModel.from_xml_string(xml)</span><br><span class="line">data = mujoco.MjData(model)</span><br><span class="line">renderer = mujoco.Renderer(model)</span><br><span class="line"></span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">renderer.update_scene(data)</span><br><span class="line"></span><br><span class="line">media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/2.png" class="" title="light"></div><p>好多了!</p><p>注意, <code>mjModel</code> 实例中的所有值都是可写入的. 虽然通常不建议这样做, 而是建议更改 <strong>XML</strong> 中的值, 因为很容易创建无效的模型, 但有些值是可以安全写入的, 例如颜色:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run this cell multiple times for different colors</span></span><br><span class="line">model.geom(<span class="string">&#x27;red_box&#x27;</span>).rgba[:<span class="number">3</span>] = np.random.rand(<span class="number">3</span>)</span><br><span class="line">renderer.update_scene(data)</span><br><span class="line">media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/3.png" class="" title="color"></div><h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a><strong>仿真</strong></h2><p>现在进行仿真并制作一个视频. 我们将使用 MuJoCo 的主要高级函数 <code>mj_step</code>, 该函数每步更新状态 $x_{t+h}=f(x_t)$.</p><p>注意, 在下面的代码块中, 我们不会在每次调用 <code>mj_step</code> 后进行渲染. 这是因为默认的时间步长是 2ms, 我们想要一个 60fps 的视频, 而不是 500fps.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">duration = <span class="number">3.8</span>  <span class="comment"># (seconds)</span></span><br><span class="line">framerate = <span class="number">60</span>  <span class="comment"># (Hz)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Simulate and display video.</span></span><br><span class="line">frames = []</span><br><span class="line">mujoco.mj_resetData(model, data)  <span class="comment"># Reset state and time.</span></span><br><span class="line"><span class="keyword">while</span> data.time &lt; duration:</span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(frames) &lt; data.time * framerate:</span><br><span class="line">    renderer.update_scene(data)</span><br><span class="line">    pixels = renderer.render()</span><br><span class="line">    frames.append(pixels)</span><br><span class="line">media.show_video(frames, fps=framerate)</span><br></pre></td></tr></table></figure><video controls >     <source src="static.mp4" type="video/mp4"></video><p>嗯… 视频在播放, 但是没有东西在动, 为什么呢?</p><p>这是因为这个模型没有<a href="https://en.wikipedia.org/wiki/Degrees_of_freedom_(mechanics)">自由度</a>(DoFs). 运动的(有惯性的)物体叫做 bodies. 我们通过给 bodies 添加 joints 来添加 DoFs, 指定它们如何相对于 parents 移动. 让我们创建一个包含几何体的新 body, 添加一个铰链关节并重新渲染, 同时使用可视化选项对象 <code>MjvOption</code> 来可视化关节轴。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;mujoco&gt;</span></span><br><span class="line"><span class="string">  &lt;worldbody&gt;</span></span><br><span class="line"><span class="string">    &lt;light name=&quot;top&quot; pos=&quot;0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;body name=&quot;box_and_sphere&quot; euler=&quot;0 0 -30&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;joint name=&quot;swing&quot; type=&quot;hinge&quot; axis=&quot;1 -1 0&quot; pos=&quot;-.2 -.2 -.2&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;red_box&quot; type=&quot;box&quot; size=&quot;.2 .2 .2&quot; rgba=&quot;1 0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;green_sphere&quot; pos=&quot;.2 .2 .2&quot; size=&quot;.1&quot; rgba=&quot;0 1 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/worldbody&gt;</span></span><br><span class="line"><span class="string">&lt;/mujoco&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = mujoco.MjModel.from_xml_string(xml)</span><br><span class="line">data = mujoco.MjData(model)</span><br><span class="line">renderer = mujoco.Renderer(model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable joint visualization option:</span></span><br><span class="line">scene_option = mujoco.MjvOption()</span><br><span class="line">scene_option.flags[mujoco.mjtVisFlag.mjVIS_JOINT] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">duration = <span class="number">3.8</span>  <span class="comment"># (seconds)</span></span><br><span class="line">framerate = <span class="number">60</span>  <span class="comment"># (Hz)</span></span><br><span class="line"></span><br><span class="line">frames = []</span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line"><span class="keyword">while</span> data.time &lt; duration:</span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(frames) &lt; data.time * framerate:</span><br><span class="line">    renderer.update_scene(data, scene_option=scene_option)</span><br><span class="line">    pixels = renderer.render()</span><br><span class="line">    frames.append(pixels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Simulate and display video.</span></span><br><span class="line">media.show_video(frames, fps=framerate)</span><br></pre></td></tr></table></figure><video controls >     <source src="rolling.mp4" type="video/mp4"></video><p>注意, 我们将 <code>box_and_sphere</code> body 绕 Z (垂直)轴旋转30°, 指令 <code>euler=&quot;0 0 -30&quot;</code>. 这样做是为了强调<a href="https://en.wikipedia.org/wiki/Kinematic_chain">运动树</a>中元素的姿态总是相对于它们的父体, 所以我们的两个几何体也通过这个变换旋转.</p><p>物理选项位于 <code>mjModel.opt</code> 中, 例如时间步:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.opt.timestep</span><br></pre></td></tr></table></figure><blockquote><p>0.002</p></blockquote><p>让我们翻转重力并重新渲染:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;default gravity&#x27;</span>, model.opt.gravity)</span><br><span class="line">model.opt.gravity = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flipped gravity&#x27;</span>, model.opt.gravity)</span><br><span class="line"></span><br><span class="line">frames = []</span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line"><span class="keyword">while</span> data.time &lt; duration:</span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(frames) &lt; data.time * framerate:</span><br><span class="line">    renderer.update_scene(data, scene_option=scene_option)</span><br><span class="line">    pixels = renderer.render()</span><br><span class="line">    frames.append(pixels)</span><br><span class="line"></span><br><span class="line">media.show_video(frames, fps=<span class="number">60</span>)</span><br></pre></td></tr></table></figure><blockquote><p>default gravity [ 0.    0.   -9.81]<br>flipped gravity [ 0.  0. 10.]</p></blockquote><video controls >     <source src="flipG.mp4" type="video/mp4"></video><p>我们也可以在 XML 中使用顶级元素 <code>&lt;option&gt;</code> 来实现它:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mujoco</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">gravity</span>=<span class="string">&quot;0 0 10&quot;</span>/&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">mujoco</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="理解自由度"><a href="#理解自由度" class="headerlink" title="理解自由度"></a><strong>理解自由度</strong></h3><p>在现实世界中, 所有刚体都有 6 个自由度: 3 个平移和 3 个旋转. 现实世界中的关节充当约束, 消除了由关节连接的物体的相对自由度. 一些物理模拟软件使用这种被称为 “Cartesian” 或 “subtractive” 的表示法, 但它的效率很低. MuJoCo 使用一种被称为 “Lagrangian”, “generalized” 或 “additive” 的表示, 其中对象没有自由度, 除非使用关节显式地添加.</p><p>我们的模型有一个铰链关节, 有一个自由度, 整个状态由这个关节的角度和角速度定义. 这是系统的广义位置和速度.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Total number of DoFs in the model:&#x27;</span>, model.nv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Generalized positions:&#x27;</span>, data.qpos)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Generalized velocities:&#x27;</span>, data.qvel)</span><br></pre></td></tr></table></figure><blockquote><p>Total number of DoFs in the model: 1<br>Generalized positions: [1.392]<br>Generalized velocities: [-3.79]</p></blockquote><p>MuJoCo 使用广义坐标的原因是在渲染或读取对象的全局位置之前需要调用函数(例如 <a href="https://mujoco.readthedocs.io/en/latest/APIreference.html#mj-forward">mj_forward</a>) - 笛卡尔位置是从广义位置派生出来的, 需要显式计算.</p><h2 id="示例-用自反转的“tippe-top”模拟自由体"><a href="#示例-用自反转的“tippe-top”模拟自由体" class="headerlink" title="示例: 用自反转的“tippe-top”模拟自由体"></a><strong>示例: 用自反转的“tippe-top”模拟自由体</strong></h2><p>一个自由物体是一个具有 6 个自由度的<a href="https://mujoco.readthedocs.io/en/latest/XMLreference.html?highlight=freejoint#body-freejoint">自由关节</a>的物体, 即 3 个平移和 3 个旋转. 我们其实可以给 <code>box_and_sphere</code> 体一个自由关节, 然后看着它下落，但是让我们看一些更有趣的东西. 一个 “tippe top” 是一个旋转的玩具, 它可以自己翻转(<a href="https://www.youtube.com/watch?v=kbYpVrdcszQ">视频</a>，<a href="https://en.wikipedia.org/wiki/Tippe_top">维基百科</a>). 我们将其建模如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">tippe_top = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;mujoco model=&quot;tippe top&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;option integrator=&quot;RK4&quot;/&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;asset&gt;</span></span><br><span class="line"><span class="string">    &lt;texture name=&quot;grid&quot; type=&quot;2d&quot; builtin=&quot;checker&quot; rgb1=&quot;.1 .2 .3&quot;</span></span><br><span class="line"><span class="string">     rgb2=&quot;.2 .3 .4&quot; width=&quot;300&quot; height=&quot;300&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;material name=&quot;grid&quot; texture=&quot;grid&quot; texrepeat=&quot;8 8&quot; reflectance=&quot;.2&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/asset&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;worldbody&gt;</span></span><br><span class="line"><span class="string">    &lt;geom size=&quot;.2 .2 .01&quot; type=&quot;plane&quot; material=&quot;grid&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;light pos=&quot;0 0 .6&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;camera name=&quot;closeup&quot; pos=&quot;0 -.1 .07&quot; xyaxes=&quot;1 0 0 0 1 2&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;body name=&quot;top&quot; pos=&quot;0 0 .02&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;freejoint/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;ball&quot; type=&quot;sphere&quot; size=&quot;.02&quot; /&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;stem&quot; type=&quot;cylinder&quot; pos=&quot;0 0 .02&quot; size=&quot;0.004 .008&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;ballast&quot; type=&quot;box&quot; size=&quot;.023 .023 0.005&quot;  pos=&quot;0 0 -.015&quot;</span></span><br><span class="line"><span class="string">       contype=&quot;0&quot; conaffinity=&quot;0&quot; group=&quot;3&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/worldbody&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;keyframe&gt;</span></span><br><span class="line"><span class="string">    &lt;key name=&quot;spinning&quot; qpos=&quot;0 0 0.02 1 0 0 0&quot; qvel=&quot;0 0 0 0 1 200&quot; /&gt;</span></span><br><span class="line"><span class="string">  &lt;/keyframe&gt;</span></span><br><span class="line"><span class="string">&lt;/mujoco&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = mujoco.MjModel.from_xml_string(tippe_top)</span><br><span class="line">renderer = mujoco.Renderer(model)</span><br><span class="line">data = mujoco.MjData(model)</span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">renderer.update_scene(data, camera=<span class="string">&quot;closeup&quot;</span>)</span><br><span class="line">media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/4.png" class="" title="tippe-top"></div><p>注意这个模型定义的几个新特性:</p><ol><li>一个使用 <code>&lt;freejoint/&gt;</code> 标签添加的6自由度自由关节.</li><li>我们使用 <code>&lt;option/&gt;</code> 标签将积分器设置为 4 阶 <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge Kutta</a>. Runge-Kutta 具有比默认的欧拉积分器更高的收敛速率, 在许多情况下, 在给定的时间步长下提高了精度.</li><li>我们在 <code>&lt;asset/&gt;</code> 标签中定义地板的网格材质, 并在 “floor” 几何体中引用它.</li><li>我们使用一种看不见的, 不碰撞的 box 几何体, 称为 ballast , 来降低顶部的质心. 低质心是发生翻转行为所必需的(与直觉相反).</li><li>我们将初始旋转状态保存为关键帧. 它绕Z轴有很高的旋转速度, 但并不完全朝向世界坐标轴, 这引入了翻转所需的对称性破坏.</li><li>我们在模型中定义了一个 <code>&lt;camera&gt;</code>, 然后使用 <code>&lt;camera&gt;</code> 参数对 <code>update_scene()</code> 进行渲染. 让我们来检查一下现在的状态:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;positions&#x27;</span>, data.qpos)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;velocities&#x27;</span>, data.qvel)</span><br></pre></td></tr></table></figure><blockquote><p>positions [0.   0.   0.02 1.   0.   0.   0.  ]<br>velocities [0. 0. 0. 0. 0. 0.]</p></blockquote><p>速度很容易解释, 6 个 0, 每个自由度一个. 那么长度为 7 的位置呢? 我们可以看到 body 最初的 2 厘米高度; 后面的 4 个数字是三维朝向, 由单位四元数定义. 三维朝向用 4 个数字表示, 角速度用 3 个数字表示. 有关更多信息, 请参阅维基百科关于<a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">四元数和空间旋转</a>的文章.</p><p>让我们做一个视频:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">duration = <span class="number">7</span>    <span class="comment"># (seconds)</span></span><br><span class="line">framerate = <span class="number">60</span>  <span class="comment"># (Hz)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Simulate and display video.</span></span><br><span class="line">frames = []</span><br><span class="line">mujoco.mj_resetDataKeyframe(model, data, <span class="number">0</span>)  <span class="comment"># Reset the state to keyframe 0</span></span><br><span class="line"><span class="keyword">while</span> data.time &lt; duration:</span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(frames) &lt; data.time * framerate:</span><br><span class="line">    renderer.update_scene(data, <span class="string">&quot;closeup&quot;</span>)</span><br><span class="line">    pixels = renderer.render()</span><br><span class="line">    frames.append(pixels)</span><br><span class="line"></span><br><span class="line">media.show_video(frames, fps=framerate)</span><br></pre></td></tr></table></figure><video controls >     <source src="tippe-top.mp4" type="video/mp4"></video><h3 id="测量-mjData-中的值"><a href="#测量-mjData-中的值" class="headerlink" title="测量 mjData 中的值"></a><strong>测量 <code>mjData</code> 中的值</strong></h3><p>如上所述, <code>mjData</code> 结构包含由模拟产生的动态变量和中间结果, 这些结果预计会在每个时间步上发生变化. 下面我们模拟了 2000 个时间步长, 并绘制了杆顶的角速度和高度作为时间的函数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">timevals = []</span><br><span class="line">angular_velocity = []</span><br><span class="line">stem_height = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># Simulate and save data</span></span><br><span class="line">mujoco.mj_resetDataKeyframe(model, data, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> data.time &lt; duration:</span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line">  timevals.append(data.time)</span><br><span class="line">  angular_velocity.append(data.qvel[<span class="number">3</span>:<span class="number">6</span>].copy())</span><br><span class="line">  stem_height.append(data.geom_xpos[<span class="number">2</span>,<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">dpi = <span class="number">120</span></span><br><span class="line">width = <span class="number">600</span></span><br><span class="line">height = <span class="number">800</span></span><br><span class="line">figsize = (width / dpi, height / dpi)</span><br><span class="line">_, ax = plt.subplots(<span class="number">2</span>, <span class="number">1</span>, figsize=figsize, dpi=dpi, sharex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].plot(timevals, angular_velocity)</span><br><span class="line">ax[<span class="number">0</span>].set_title(<span class="string">&#x27;angular velocity&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].set_ylabel(<span class="string">&#x27;radians / second&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax[<span class="number">1</span>].plot(timevals, stem_height)</span><br><span class="line">ax[<span class="number">1</span>].set_xlabel(<span class="string">&#x27;time (seconds)&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].set_ylabel(<span class="string">&#x27;meters&#x27;</span>)</span><br><span class="line">_ = ax[<span class="number">1</span>].set_title(<span class="string">&#x27;stem height&#x27;</span>)</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/5.png" class="" title="mjData"></div><h2 id="实例-一个混沌摆"><a href="#实例-一个混沌摆" class="headerlink" title="实例: 一个混沌摆"></a><strong>实例: 一个混沌摆</strong></h2><p>下面是一个混沌摆模型, 与旧金山探索博物馆的<a href="https://www.exploratorium.edu/exhibits/chaotic-pendulum">这个</a>模型相似.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">chaotic_pendulum = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;mujoco&gt;</span></span><br><span class="line"><span class="string">  &lt;option timestep=&quot;.001&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;flag energy=&quot;enable&quot; contact=&quot;disable&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/option&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;default&gt;</span></span><br><span class="line"><span class="string">    &lt;joint type=&quot;hinge&quot; axis=&quot;0 -1 0&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;geom type=&quot;capsule&quot; size=&quot;.02&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/default&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;worldbody&gt;</span></span><br><span class="line"><span class="string">    &lt;light pos=&quot;0 -.4 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;camera name=&quot;fixed&quot; pos=&quot;0 -1 0&quot; xyaxes=&quot;1 0 0 0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;body name=&quot;0&quot; pos=&quot;0 0 .2&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;joint name=&quot;root&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom fromto=&quot;-.2 0 0 .2 0 0&quot; rgba=&quot;1 1 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom fromto=&quot;0 0 0 0 0 -.25&quot; rgba=&quot;1 1 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;body name=&quot;1&quot; pos=&quot;-.2 0 0&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;joint/&gt;</span></span><br><span class="line"><span class="string">        &lt;geom fromto=&quot;0 0 0 0 0 -.2&quot; rgba=&quot;1 0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">      &lt;body name=&quot;2&quot; pos=&quot;.2 0 0&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;joint/&gt;</span></span><br><span class="line"><span class="string">        &lt;geom fromto=&quot;0 0 0 0 0 -.2&quot; rgba=&quot;0 1 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">      &lt;body name=&quot;3&quot; pos=&quot;0 0 -.25&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;joint/&gt;</span></span><br><span class="line"><span class="string">        &lt;geom fromto=&quot;0 0 0 0 0 -.2&quot; rgba=&quot;0 0 1 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/worldbody&gt;</span></span><br><span class="line"><span class="string">&lt;/mujoco&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = mujoco.MjModel.from_xml_string(chaotic_pendulum)</span><br><span class="line">renderer = mujoco.Renderer(model, <span class="number">480</span>, <span class="number">640</span>)</span><br><span class="line">data = mujoco.MjData(model)</span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">renderer.update_scene(data, camera=<span class="string">&quot;fixed&quot;</span>)</span><br><span class="line">media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/6.png" class="" title="chaotic"></div><h3 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a><strong>Timing</strong></h3><p>让我们来看看它在运行时的视频, 同时我们对组件进行计时:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setup</span></span><br><span class="line">n_seconds = <span class="number">6</span></span><br><span class="line">framerate = <span class="number">30</span>  <span class="comment"># Hz</span></span><br><span class="line">n_frames = <span class="built_in">int</span>(n_seconds * framerate)</span><br><span class="line">frames = []</span><br><span class="line">renderer = mujoco.Renderer(model, <span class="number">240</span>, <span class="number">320</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set initial state</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line">data.joint(<span class="string">&#x27;root&#x27;</span>).qvel = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># simulate and record frames</span></span><br><span class="line">frame = <span class="number">0</span></span><br><span class="line">sim_time = <span class="number">0</span></span><br><span class="line">render_time = <span class="number">0</span></span><br><span class="line">n_steps = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_frames):</span><br><span class="line">  <span class="keyword">while</span> data.time * framerate &lt; i:</span><br><span class="line">    tic = time.time()</span><br><span class="line">    mujoco.mj_step(model, data)</span><br><span class="line">    sim_time += time.time() - tic</span><br><span class="line">    n_steps += <span class="number">1</span></span><br><span class="line">  tic = time.time()</span><br><span class="line">  renderer.update_scene(data, <span class="string">&quot;fixed&quot;</span>)</span><br><span class="line">  frame = renderer.render()</span><br><span class="line">  render_time += time.time() - tic</span><br><span class="line">  frames.append(frame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print timing and play video</span></span><br><span class="line">step_time = <span class="number">1e6</span>*sim_time/n_steps</span><br><span class="line">step_fps = n_steps/sim_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;simulation: <span class="subst">&#123;step_time:<span class="number">5.3</span>g&#125;</span> μs/step  (<span class="subst">&#123;step_fps:<span class="number">5.0</span>f&#125;</span>Hz)&#x27;</span>)</span><br><span class="line">frame_time = <span class="number">1e6</span>*render_time/n_frames</span><br><span class="line">frame_fps = n_frames/render_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;rendering:  <span class="subst">&#123;frame_time:<span class="number">5.3</span>g&#125;</span> μs/frame (<span class="subst">&#123;frame_fps:<span class="number">5.0</span>f&#125;</span>Hz)&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show video</span></span><br><span class="line">media.show_video(frames, fps=framerate)</span><br></pre></td></tr></table></figure><blockquote><p>simulation:  3.74 μs/step  (267581Hz)<br>rendering:  3.31e+04 μs/frame (   30Hz)</p></blockquote><video controls >     <source src="chaotic.mp4" type="video/mp4"></video><p>注意, 渲染比模拟物理要慢得多.</p><h3 id="Chaos"><a href="#Chaos" class="headerlink" title="Chaos"></a><strong>Chaos</strong></h3><p>这是一个<a href="https://en.wikipedia.org/wiki/Chaos_theory">混沌</a>系统(初始条件下的小扰动会迅速累积):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PERTURBATION = <span class="number">1e-7</span></span><br><span class="line">SIM_DURATION = <span class="number">10</span> <span class="comment"># seconds</span></span><br><span class="line">NUM_REPEATS = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># preallocate</span></span><br><span class="line">n_steps = <span class="built_in">int</span>(SIM_DURATION / model.opt.timestep)</span><br><span class="line">sim_time = np.zeros(n_steps)</span><br><span class="line">angle = np.zeros(n_steps)</span><br><span class="line">energy = np.zeros(n_steps)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare plotting axes</span></span><br><span class="line">_, ax = plt.subplots(<span class="number">2</span>, <span class="number">1</span>, figsize=(<span class="number">8</span>, <span class="number">6</span>), sharex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># simulate NUM_REPEATS times with slightly different initial conditions</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(NUM_REPEATS):</span><br><span class="line">  <span class="comment"># initialize</span></span><br><span class="line">  mujoco.mj_resetData(model, data)</span><br><span class="line">  data.qvel[<span class="number">0</span>] = <span class="number">10</span> <span class="comment"># root joint velocity</span></span><br><span class="line">  <span class="comment"># perturb initial velocities</span></span><br><span class="line">  data.qvel[:] += PERTURBATION * np.random.randn(model.nv)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># simulate</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_steps):</span><br><span class="line">    mujoco.mj_step(model, data)</span><br><span class="line">    sim_time[i] = data.time</span><br><span class="line">    angle[i] = data.joint(<span class="string">&#x27;root&#x27;</span>).qpos</span><br><span class="line">    energy[i] = data.energy[<span class="number">0</span>] + data.energy[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># plot</span></span><br><span class="line">  ax[<span class="number">0</span>].plot(sim_time, angle)</span><br><span class="line">  ax[<span class="number">1</span>].plot(sim_time, energy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># finalize plot</span></span><br><span class="line">ax[<span class="number">0</span>].set_title(<span class="string">&#x27;root angle&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].set_ylabel(<span class="string">&#x27;radian&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].set_title(<span class="string">&#x27;total energy&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].set_ylabel(<span class="string">&#x27;Joule&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].set_xlabel(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><div style="width:70%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/7.png" class="" title="chaos"></div><h3 id="时间步长和精度"><a href="#时间步长和精度" class="headerlink" title="时间步长和精度"></a><strong>时间步长和精度</strong></h3><p><strong>问题:</strong> 为什么能量会发生变化? 没有摩擦和阻尼, 这个系统应该节省能量.</p><p><strong>答:</strong> 因为时间的离散化.</p><p>如果我们减少时间步长, 我们将获得更好的精度和更好的节能:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SIM_DURATION = <span class="number">10</span> <span class="comment"># (seconds)</span></span><br><span class="line">TIMESTEPS = np.power(<span class="number">10</span>, np.linspace(-<span class="number">2</span>, -<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare plotting axes</span></span><br><span class="line">_, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dt <span class="keyword">in</span> TIMESTEPS:</span><br><span class="line">   <span class="comment"># set timestep, print</span></span><br><span class="line">  model.opt.timestep = dt</span><br><span class="line"></span><br><span class="line">  <span class="comment"># allocate</span></span><br><span class="line">  n_steps = <span class="built_in">int</span>(SIM_DURATION / model.opt.timestep)</span><br><span class="line">  sim_time = np.zeros(n_steps)</span><br><span class="line">  energy = np.zeros(n_steps)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># initialize</span></span><br><span class="line">  mujoco.mj_resetData(model, data)</span><br><span class="line">  data.qvel[<span class="number">0</span>] = <span class="number">9</span> <span class="comment"># root joint velocity</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># simulate</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; steps at dt = &#123;:2.2g&#125;ms&#x27;</span>.<span class="built_in">format</span>(n_steps, <span class="number">1000</span>*dt))</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_steps):</span><br><span class="line">    mujoco.mj_step(model, data)</span><br><span class="line">    sim_time[i] = data.time</span><br><span class="line">    energy[i] = data.energy[<span class="number">0</span>] + data.energy[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># plot</span></span><br><span class="line">  ax.plot(sim_time, energy, label=<span class="string">&#x27;timestep = &#123;:2.2g&#125;ms&#x27;</span>.<span class="built_in">format</span>(<span class="number">1000</span>*dt))</span><br><span class="line"></span><br><span class="line"><span class="comment"># finalize plot</span></span><br><span class="line">ax.set_title(<span class="string">&#x27;energy&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Joule&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">ax.legend(frameon=<span class="literal">True</span>);</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><blockquote><p>1000 steps at dt = 10ms<br>3162 steps at dt = 3.2ms<br>10000 steps at dt =  1ms<br>31622 steps at dt = 0.32ms<br>100000 steps at dt = 0.1ms</p></blockquote><div style="width:60%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/8.png" class="" title="accuracy"></div><h3 id="时间步长和敛散性"><a href="#时间步长和敛散性" class="headerlink" title="时间步长和敛散性"></a><strong>时间步长和敛散性</strong></h3><p>当我们增加时间步长时, 模拟会迅速发散:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">SIM_DURATION = <span class="number">10</span> <span class="comment"># (seconds)</span></span><br><span class="line">TIMESTEPS = np.power(<span class="number">10</span>, np.linspace(-<span class="number">2</span>, -<span class="number">1.5</span>, <span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># get plotting axes</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dt <span class="keyword">in</span> TIMESTEPS:</span><br><span class="line">  <span class="comment"># set timestep</span></span><br><span class="line">  model.opt.timestep = dt</span><br><span class="line"></span><br><span class="line">  <span class="comment"># allocate</span></span><br><span class="line">  n_steps = <span class="built_in">int</span>(SIM_DURATION / model.opt.timestep)</span><br><span class="line">  sim_time = np.zeros(n_steps)</span><br><span class="line">  energy = np.zeros(n_steps) * np.nan</span><br><span class="line">  speed = np.zeros(n_steps) * np.nan</span><br><span class="line"></span><br><span class="line">  <span class="comment"># initialize</span></span><br><span class="line">  mujoco.mj_resetData(model, data)</span><br><span class="line">  data.qvel[<span class="number">0</span>] = <span class="number">11</span> <span class="comment"># set root joint velocity</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># simulate</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;simulating &#123;&#125; steps at dt = &#123;:2.2g&#125;ms&#x27;</span>.<span class="built_in">format</span>(n_steps, <span class="number">1000</span>*dt))</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_steps):</span><br><span class="line">    mujoco.mj_step(model, data)</span><br><span class="line">    <span class="keyword">if</span> data.warning.number.<span class="built_in">any</span>():</span><br><span class="line">      warning_index = np.nonzero(data.warning.number)[<span class="number">0</span>]</span><br><span class="line">      warning = mujoco.mjtWarning(warning_index).name</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f&#x27;stopped due to divergence (<span class="subst">&#123;warning&#125;</span>) at timestep <span class="subst">&#123;i&#125;</span>.\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    sim_time[i] = data.time</span><br><span class="line">    energy[i] = <span class="built_in">sum</span>(<span class="built_in">abs</span>(data.qvel))</span><br><span class="line">    speed[i] = np.linalg.norm(data.qvel)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># plot</span></span><br><span class="line">  ax.plot(sim_time, energy, label=<span class="string">&#x27;timestep = &#123;:2.2g&#125;ms&#x27;</span>.<span class="built_in">format</span>(<span class="number">1000</span>*dt))</span><br><span class="line">  ax.set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># finalize plot</span></span><br><span class="line">ax.set_ybound(<span class="number">1</span>, <span class="number">1e3</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;energy&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Joule&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">ax.legend(frameon=<span class="literal">True</span>, loc=<span class="string">&#x27;lower right&#x27;</span>);</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><blockquote><p>simulating 1000 steps at dt = 10ms<br>stopped due to divergence (mjWARN_BADQACC) at timestep 385.</p><p>simulating 825 steps at dt = 12ms<br>stopped due to divergence (mjWARN_BADQACC) at timestep 322.</p><p>simulating 681 steps at dt = 15ms<br>stopped due to divergence (mjWARN_BADQACC) at timestep 166.</p><p>simulating 562 steps at dt = 18ms<br>stopped due to divergence (mjWARN_BADQACC) at timestep 105.</p><p>simulating 464 steps at dt = 22ms<br>stopped due to divergence (mjWARN_BADQACC) at timestep 84.</p><p>simulating 383 steps at dt = 26ms<br>stopped due to divergence (mjWARN_BADQACC) at timestep 61.</p><p>simulating 316 steps at dt = 32ms<br>stopped due to divergence (mjWARN_BADQACC) at timestep 45.</p></blockquote><div style="width:60%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/9.png" class="" title="divergence"></div><h2 id="接触力"><a href="#接触力" class="headerlink" title="接触力"></a><strong>接触力</strong></h2><p>让我们回到我们的盒子和球体的例子, 给它一个自由关节:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">free_body_MJCF = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;mujoco&gt;</span></span><br><span class="line"><span class="string">  &lt;asset&gt;</span></span><br><span class="line"><span class="string">    &lt;texture name=&quot;grid&quot; type=&quot;2d&quot; builtin=&quot;checker&quot; rgb1=&quot;.1 .2 .3&quot; </span></span><br><span class="line"><span class="string">    rgb2=&quot;.2 .3 .4&quot; width=&quot;300&quot; height=&quot;300&quot; mark=&quot;edge&quot; markrgb=&quot;.2 .3 .4&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;material name=&quot;grid&quot; texture=&quot;grid&quot; texrepeat=&quot;2 2&quot; texuniform=&quot;true&quot;</span></span><br><span class="line"><span class="string">    reflectance=&quot;.2&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/asset&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;worldbody&gt;</span></span><br><span class="line"><span class="string">    &lt;light pos=&quot;0 0 1&quot; mode=&quot;trackcom&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;geom name=&quot;ground&quot; type=&quot;plane&quot; pos=&quot;0 0 -.5&quot; size=&quot;2 2 .1&quot; material=&quot;grid&quot; solimp=&quot;.99 .99 .01&quot; solref=&quot;.001 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;body name=&quot;box_and_sphere&quot; pos=&quot;0 0 0&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;freejoint/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;red_box&quot; type=&quot;box&quot; size=&quot;.1 .1 .1&quot; rgba=&quot;1 0 0 1&quot; solimp=&quot;.99 .99 .01&quot;  solref=&quot;.001 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;green_sphere&quot; size=&quot;.06&quot; pos=&quot;.1 .1 .1&quot; rgba=&quot;0 1 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;camera name=&quot;fixed&quot; pos=&quot;0 -.6 .3&quot; xyaxes=&quot;1 0 0 0 1 2&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;camera name=&quot;track&quot; pos=&quot;0 -.6 .3&quot; xyaxes=&quot;1 0 0 0 1 2&quot; mode=&quot;track&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/worldbody&gt;</span></span><br><span class="line"><span class="string">&lt;/mujoco&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = mujoco.MjModel.from_xml_string(free_body_MJCF)</span><br><span class="line">renderer = mujoco.Renderer(model, <span class="number">400</span>, <span class="number">600</span>)</span><br><span class="line">data = mujoco.MjData(model)</span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">renderer.update_scene(data, <span class="string">&quot;fixed&quot;</span>)</span><br><span class="line">media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/10.png" class="" title="contact"></div><p>让我们渲染这个 body 在地板上滚动, 慢动作, 同时可视化接触点和力:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">n_frames = <span class="number">200</span></span><br><span class="line">height = <span class="number">240</span></span><br><span class="line">width = <span class="number">320</span></span><br><span class="line">frames = []</span><br><span class="line">renderer = mujoco.Renderer(model, height, width)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualize contact frames and forces, make body transparent</span></span><br><span class="line">options = mujoco.MjvOption()</span><br><span class="line">mujoco.mjv_defaultOption(options)</span><br><span class="line">options.flags[mujoco.mjtVisFlag.mjVIS_CONTACTPOINT] = <span class="literal">True</span></span><br><span class="line">options.flags[mujoco.mjtVisFlag.mjVIS_CONTACTFORCE] = <span class="literal">True</span></span><br><span class="line">options.flags[mujoco.mjtVisFlag.mjVIS_TRANSPARENT] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tweak scales of contact visualization elements</span></span><br><span class="line">model.vis.scale.contactwidth = <span class="number">0.1</span></span><br><span class="line">model.vis.scale.contactheight = <span class="number">0.03</span></span><br><span class="line">model.vis.scale.forcewidth = <span class="number">0.05</span></span><br><span class="line">model.vis.<span class="built_in">map</span>.force = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># random initial rotational velocity:</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line">data.qvel[<span class="number">3</span>:<span class="number">6</span>] = <span class="number">5</span>*np.random.randn(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># simulate and render</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_frames):</span><br><span class="line">  <span class="keyword">while</span> data.time &lt; i/<span class="number">120.0</span>: <span class="comment">#1/4x real time</span></span><br><span class="line">    mujoco.mj_step(model, data)</span><br><span class="line">  renderer.update_scene(data, <span class="string">&quot;track&quot;</span>, options)</span><br><span class="line">  frame = renderer.render()</span><br><span class="line">  frames.append(frame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show video</span></span><br><span class="line">media.show_video(frames, fps=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><video controls >     <source src="force.mp4" type="video/mp4"></video><h3 id="分析接触力"><a href="#分析接触力" class="headerlink" title="分析接触力"></a><strong>分析接触力</strong></h3><p>让我们重新运行上述模拟(使用不同的随机初始条件)并绘制与接触相关的一些值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">n_steps = <span class="number">499</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># allocate</span></span><br><span class="line">sim_time = np.zeros(n_steps)</span><br><span class="line">ncon = np.zeros(n_steps)</span><br><span class="line">force = np.zeros((n_steps,<span class="number">3</span>))</span><br><span class="line">velocity = np.zeros((n_steps, model.nv))</span><br><span class="line">penetration = np.zeros(n_steps)</span><br><span class="line">acceleration = np.zeros((n_steps, model.nv))</span><br><span class="line">forcetorque = np.zeros(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># random initial rotational velocity:</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line">data.qvel[<span class="number">3</span>:<span class="number">6</span>] = <span class="number">2</span>*np.random.randn(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># simulate and save data</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_steps):</span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line">  sim_time[i] = data.time</span><br><span class="line">  ncon[i] = data.ncon</span><br><span class="line">  velocity[i] = data.qvel[:]</span><br><span class="line">  acceleration[i] = data.qacc[:]</span><br><span class="line">  <span class="comment"># iterate over active contacts, save force and distance</span></span><br><span class="line">  <span class="keyword">for</span> j,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(data.contact):</span><br><span class="line">    mujoco.mj_contactForce(model, data, j, forcetorque)</span><br><span class="line">    force[i] += forcetorque[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    penetration[i] = <span class="built_in">min</span>(penetration[i], c.dist)</span><br><span class="line">  <span class="comment"># we could also do</span></span><br><span class="line">  <span class="comment"># force[i] += data.qfrc_constraint[0:3]</span></span><br><span class="line">  <span class="comment"># do you see why?</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">_, ax = plt.subplots(<span class="number">3</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">lines = ax[<span class="number">0</span>,<span class="number">0</span>].plot(sim_time, force)</span><br><span class="line">ax[<span class="number">0</span>,<span class="number">0</span>].set_title(<span class="string">&#x27;contact force&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>,<span class="number">0</span>].set_ylabel(<span class="string">&#x27;Newton&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>,<span class="number">0</span>].legend(<span class="built_in">iter</span>(lines), (<span class="string">&#x27;normal z&#x27;</span>, <span class="string">&#x27;friction x&#x27;</span>, <span class="string">&#x27;friction y&#x27;</span>));</span><br><span class="line"></span><br><span class="line">ax[<span class="number">1</span>,<span class="number">0</span>].plot(sim_time, acceleration)</span><br><span class="line">ax[<span class="number">1</span>,<span class="number">0</span>].set_title(<span class="string">&#x27;acceleration&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>,<span class="number">0</span>].set_ylabel(<span class="string">&#x27;(meter,radian)/s/s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax[<span class="number">2</span>,<span class="number">0</span>].plot(sim_time, velocity)</span><br><span class="line">ax[<span class="number">2</span>,<span class="number">0</span>].set_title(<span class="string">&#x27;velocity&#x27;</span>)</span><br><span class="line">ax[<span class="number">2</span>,<span class="number">0</span>].set_ylabel(<span class="string">&#x27;(meter,radian)/s&#x27;</span>)</span><br><span class="line">ax[<span class="number">2</span>,<span class="number">0</span>].set_xlabel(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>,<span class="number">1</span>].plot(sim_time, ncon)</span><br><span class="line">ax[<span class="number">0</span>,<span class="number">1</span>].set_title(<span class="string">&#x27;number of contacts&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>,<span class="number">1</span>].set_yticks(<span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax[<span class="number">1</span>,<span class="number">1</span>].plot(sim_time, force[:,<span class="number">0</span>])</span><br><span class="line">ax[<span class="number">1</span>,<span class="number">1</span>].set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>,<span class="number">1</span>].set_title(<span class="string">&#x27;normal (z) force - log scale&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>,<span class="number">1</span>].set_ylabel(<span class="string">&#x27;Newton&#x27;</span>)</span><br><span class="line">z_gravity = -model.opt.gravity[<span class="number">2</span>]</span><br><span class="line">mg = model.body(<span class="string">&quot;box_and_sphere&quot;</span>).mass[<span class="number">0</span>] * z_gravity</span><br><span class="line">mg_line = ax[<span class="number">1</span>,<span class="number">1</span>].plot(sim_time, np.ones(n_steps)*mg, label=<span class="string">&#x27;m*g&#x27;</span>, linewidth=<span class="number">1</span>)</span><br><span class="line">ax[<span class="number">1</span>,<span class="number">1</span>].legend()</span><br><span class="line"></span><br><span class="line">ax[<span class="number">2</span>,<span class="number">1</span>].plot(sim_time, <span class="number">1000</span>*penetration)</span><br><span class="line">ax[<span class="number">2</span>,<span class="number">1</span>].set_title(<span class="string">&#x27;penetration depth&#x27;</span>)</span><br><span class="line">ax[<span class="number">2</span>,<span class="number">1</span>].set_ylabel(<span class="string">&#x27;millimeter&#x27;</span>)</span><br><span class="line">ax[<span class="number">2</span>,<span class="number">1</span>].set_xlabel(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><div style="width:80%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/11.png" class="" title="analysis"></div><h3 id="摩擦力"><a href="#摩擦力" class="headerlink" title="摩擦力"></a><strong>摩擦力</strong></h3><p>让我们看看改变摩擦值的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">MJCF = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;mujoco&gt;</span></span><br><span class="line"><span class="string">  &lt;asset&gt;</span></span><br><span class="line"><span class="string">    &lt;texture name=&quot;grid&quot; type=&quot;2d&quot; builtin=&quot;checker&quot; rgb1=&quot;.1 .2 .3&quot;</span></span><br><span class="line"><span class="string">     rgb2=&quot;.2 .3 .4&quot; width=&quot;300&quot; height=&quot;300&quot; mark=&quot;none&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;material name=&quot;grid&quot; texture=&quot;grid&quot; texrepeat=&quot;6 6&quot;</span></span><br><span class="line"><span class="string">     texuniform=&quot;true&quot; reflectance=&quot;.2&quot;/&gt;</span></span><br><span class="line"><span class="string">     &lt;material name=&quot;wall&quot; rgba=&#x27;.5 .5 .5 1&#x27;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/asset&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;default&gt;</span></span><br><span class="line"><span class="string">    &lt;geom type=&quot;box&quot; size=&quot;.05 .05 .05&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;joint type=&quot;free&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/default&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;worldbody&gt;</span></span><br><span class="line"><span class="string">    &lt;light name=&quot;light&quot; pos=&quot;-.2 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;geom name=&quot;ground&quot; type=&quot;plane&quot; size=&quot;.5 .5 10&quot; material=&quot;grid&quot;</span></span><br><span class="line"><span class="string">     zaxis=&quot;-.3 0 1&quot; friction=&quot;.1&quot;/&gt; </span></span><br><span class="line"><span class="string">    &lt;camera name=&quot;y&quot; pos=&quot;-.1 -.6 .3&quot; xyaxes=&quot;1 0 0 0 1 2&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;body pos=&quot;0 0 .1&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;joint/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;body pos=&quot;0 .2 .1&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;joint/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom friction=&quot;.33&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/worldbody&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/mujoco&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">n_frames = <span class="number">60</span></span><br><span class="line">height = <span class="number">300</span></span><br><span class="line">width = <span class="number">300</span></span><br><span class="line">frames = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">model = mujoco.MjModel.from_xml_string(MJCF)</span><br><span class="line">data = mujoco.MjData(model)</span><br><span class="line">renderer = mujoco.Renderer(model, height, width)</span><br><span class="line"></span><br><span class="line"><span class="comment"># simulate and render</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_frames):</span><br><span class="line">  <span class="keyword">while</span> data.time &lt; i/<span class="number">30.0</span>:</span><br><span class="line">    mujoco.mj_step(model, data)</span><br><span class="line">  renderer.update_scene(data, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">  frame = renderer.render()</span><br><span class="line">  frames.append(frame)</span><br><span class="line">media.show_video(frames, fps=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><video controls >     <source src="friction.mp4" type="video/mp4"></video><h2 id="肌腱-执行器和传感器"><a href="#肌腱-执行器和传感器" class="headerlink" title="肌腱, 执行器和传感器"></a><strong>肌腱, 执行器和传感器</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">MJCF = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;mujoco&gt;</span></span><br><span class="line"><span class="string">  &lt;asset&gt;</span></span><br><span class="line"><span class="string">    &lt;texture name=&quot;grid&quot; type=&quot;2d&quot; builtin=&quot;checker&quot; rgb1=&quot;.1 .2 .3&quot;</span></span><br><span class="line"><span class="string">     rgb2=&quot;.2 .3 .4&quot; width=&quot;300&quot; height=&quot;300&quot; mark=&quot;none&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;material name=&quot;grid&quot; texture=&quot;grid&quot; texrepeat=&quot;1 1&quot;</span></span><br><span class="line"><span class="string">     texuniform=&quot;true&quot; reflectance=&quot;.2&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/asset&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;worldbody&gt;</span></span><br><span class="line"><span class="string">    &lt;light name=&quot;light&quot; pos=&quot;0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;geom name=&quot;floor&quot; type=&quot;plane&quot; pos=&quot;0 0 -.5&quot; size=&quot;2 2 .1&quot; material=&quot;grid&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;site name=&quot;anchor&quot; pos=&quot;0 0 .3&quot; size=&quot;.01&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;camera name=&quot;fixed&quot; pos=&quot;0 -1.3 .5&quot; xyaxes=&quot;1 0 0 0 1 2&quot;/&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;geom name=&quot;pole&quot; type=&quot;cylinder&quot; fromto=&quot;.3 0 -.5 .3 0 -.1&quot; size=&quot;.04&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;body name=&quot;bat&quot; pos=&quot;.3 0 -.1&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;joint name=&quot;swing&quot; type=&quot;hinge&quot; damping=&quot;1&quot; axis=&quot;0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;bat&quot; type=&quot;capsule&quot; fromto=&quot;0 0 .04 0 -.3 .04&quot;</span></span><br><span class="line"><span class="string">       size=&quot;.04&quot; rgba=&quot;0 0 1 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;body name=&quot;box_and_sphere&quot; pos=&quot;0 0 0&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;joint name=&quot;free&quot; type=&quot;free&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;red_box&quot; type=&quot;box&quot; size=&quot;.1 .1 .1&quot; rgba=&quot;1 0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;green_sphere&quot;  size=&quot;.06&quot; pos=&quot;.1 .1 .1&quot; rgba=&quot;0 1 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;site name=&quot;hook&quot; pos=&quot;-.1 -.1 -.1&quot; size=&quot;.01&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;site name=&quot;IMU&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/worldbody&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;tendon&gt;</span></span><br><span class="line"><span class="string">    &lt;spatial name=&quot;wire&quot; limited=&quot;true&quot; range=&quot;0 0.35&quot; width=&quot;0.003&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;site site=&quot;anchor&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;site site=&quot;hook&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/spatial&gt;</span></span><br><span class="line"><span class="string">  &lt;/tendon&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;actuator&gt;</span></span><br><span class="line"><span class="string">    &lt;motor name=&quot;my_motor&quot; joint=&quot;swing&quot; gear=&quot;1&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/actuator&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;sensor&gt;</span></span><br><span class="line"><span class="string">    &lt;accelerometer name=&quot;accelerometer&quot; site=&quot;IMU&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/sensor&gt;</span></span><br><span class="line"><span class="string">&lt;/mujoco&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = mujoco.MjModel.from_xml_string(MJCF)</span><br><span class="line">renderer = mujoco.Renderer(model, <span class="number">480</span>, <span class="number">480</span>)</span><br><span class="line">data = mujoco.MjData(model)</span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">renderer.update_scene(data, <span class="string">&quot;fixed&quot;</span>)</span><br><span class="line">media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/12.png" class="" title="bat"></div><p>驱动球棒和被动的皮纳塔.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">n_frames = <span class="number">180</span></span><br><span class="line">height = <span class="number">240</span></span><br><span class="line">width = <span class="number">320</span></span><br><span class="line">frames = []</span><br><span class="line">fps = <span class="number">60.0</span></span><br><span class="line">times = []</span><br><span class="line">sensordata = []</span><br><span class="line"></span><br><span class="line">renderer = mujoco.Renderer(model, height, width)</span><br><span class="line"></span><br><span class="line"><span class="comment"># constant actuator signal</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line">data.ctrl = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># simulate and render</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_frames):</span><br><span class="line">  <span class="keyword">while</span> data.time &lt; i/fps:</span><br><span class="line">    mujoco.mj_step(model, data)</span><br><span class="line">    times.append(data.time)</span><br><span class="line">    sensordata.append(data.sensor(<span class="string">&#x27;accelerometer&#x27;</span>).data.copy())</span><br><span class="line">  renderer.update_scene(data, <span class="string">&quot;fixed&quot;</span>)</span><br><span class="line">  frame = renderer.render()</span><br><span class="line">  frames.append(frame)</span><br><span class="line"></span><br><span class="line">media.show_video(frames, fps=fps)</span><br></pre></td></tr></table></figure><video controls >     <source src="bat.mp4" type="video/mp4"></video><p>让我们绘制加速度传感器测量的值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.gca()</span><br><span class="line"></span><br><span class="line">ax.plot(np.asarray(times), np.asarray(sensordata), label=<span class="string">&#x27;timestep = &#123;:2.2g&#125;ms&#x27;</span>.<span class="built_in">format</span>(<span class="number">1000</span>*dt))</span><br><span class="line"></span><br><span class="line"><span class="comment"># finalize plot</span></span><br><span class="line">ax.set_title(<span class="string">&#x27;Accelerometer values&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;meter/second^2&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">ax.legend(frameon=<span class="literal">True</span>, loc=<span class="string">&#x27;lower right&#x27;</span>);</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><div style="width:60%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/13.png" class="" title="acceleration"></div><p>注意 body 被球棒击中的瞬间是如何在加速度测量中清晰可见的.</p><h2 id="高级渲染"><a href="#高级渲染" class="headerlink" title="高级渲染"></a><strong>高级渲染</strong></h2><p>与关节可视化一样, 附加的渲染选项作为参数公开给 <code>render</code> 方法.</p><p>让我们回到第一个模型:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;mujoco&gt;</span></span><br><span class="line"><span class="string">  &lt;worldbody&gt;</span></span><br><span class="line"><span class="string">    &lt;light name=&quot;top&quot; pos=&quot;0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;body name=&quot;box_and_sphere&quot; euler=&quot;0 0 -30&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;joint name=&quot;swing&quot; type=&quot;hinge&quot; axis=&quot;1 -1 0&quot; pos=&quot;-.2 -.2 -.2&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;red_box&quot; type=&quot;box&quot; size=&quot;.2 .2 .2&quot; rgba=&quot;1 0 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;geom name=&quot;green_sphere&quot; pos=&quot;.2 .2 .2&quot; size=&quot;.1&quot; rgba=&quot;0 1 0 1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/worldbody&gt;</span></span><br><span class="line"><span class="string">&lt;/mujoco&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = mujoco.MjModel.from_xml_string(xml)</span><br><span class="line">renderer = mujoco.Renderer(model)</span><br><span class="line">data = mujoco.MjData(model)</span><br><span class="line"></span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line">renderer.update_scene(data)</span><br><span class="line">media.show_image(renderer.render())</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/14.png" class="" title="render"></div><h3 id="启用透明度和坐标轴可视化"><a href="#启用透明度和坐标轴可视化" class="headerlink" title="启用透明度和坐标轴可视化"></a><strong>启用透明度和坐标轴可视化</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@title Enable transparency and frame visualization</span></span><br><span class="line"></span><br><span class="line">scene_option.frame = mujoco.mjtFrame.mjFRAME_GEOM</span><br><span class="line">scene_option.flags[mujoco.mjtVisFlag.mjVIS_TRANSPARENT] = <span class="literal">True</span></span><br><span class="line">renderer.update_scene(data, scene_option=scene_option)</span><br><span class="line">frame = renderer.render()</span><br><span class="line">media.show_image(frame)</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/15.png" class="" title="transparency"></div><h3 id="深度渲染"><a href="#深度渲染" class="headerlink" title="深度渲染"></a><strong>深度渲染</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@title Depth rendering</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># update renderer to render depth</span></span><br><span class="line">renderer.enable_depth_rendering()</span><br><span class="line"></span><br><span class="line"><span class="comment"># reset the scene</span></span><br><span class="line">renderer.update_scene(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># depth is a float array, in meters.</span></span><br><span class="line">depth = renderer.render()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Shift nearest values to the origin.</span></span><br><span class="line">depth -= depth.<span class="built_in">min</span>()</span><br><span class="line"><span class="comment"># Scale by 2 mean distances of near rays.</span></span><br><span class="line">depth /= <span class="number">2</span>*depth[depth &lt;= <span class="number">1</span>].mean()</span><br><span class="line"><span class="comment"># Scale to [0, 255]</span></span><br><span class="line">pixels = <span class="number">255</span>*np.clip(depth, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">media.show_image(pixels.astype(np.uint8))</span><br><span class="line"></span><br><span class="line">renderer.disable_depth_rendering()</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/16.png" class="" title="depth"></div><h3 id="分割渲染"><a href="#分割渲染" class="headerlink" title="分割渲染"></a><strong>分割渲染</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@title Segmentation rendering</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># update renderer to render segmentation</span></span><br><span class="line">renderer.enable_segmentation_rendering()</span><br><span class="line"></span><br><span class="line"><span class="comment"># reset the scene</span></span><br><span class="line">renderer.update_scene(data)</span><br><span class="line"></span><br><span class="line">seg = renderer.render()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display the contents of the first channel, which contains object</span></span><br><span class="line"><span class="comment"># IDs. The second channel, seg[:, :, 1], contains object types.</span></span><br><span class="line">geom_ids = seg[:, :, <span class="number">0</span>]</span><br><span class="line"><span class="comment"># Infinity is mapped to -1</span></span><br><span class="line">geom_ids = geom_ids.astype(np.float64) + <span class="number">1</span></span><br><span class="line"><span class="comment"># Scale to [0, 1]</span></span><br><span class="line">geom_ids = geom_ids / geom_ids.<span class="built_in">max</span>()</span><br><span class="line">pixels = <span class="number">255</span>*geom_ids</span><br><span class="line">media.show_image(pixels.astype(np.uint8))</span><br><span class="line"></span><br><span class="line">renderer.disable_segmentation_rendering()</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/17.png" class="" title="segmentation"></div><h3 id="相机矩阵"><a href="#相机矩阵" class="headerlink" title="相机矩阵"></a><strong>相机矩阵</strong></h3><p>有关相机矩阵的描述, 请参阅维基百科上关于<a href="https://en.wikipedia.org/wiki/Camera_matrix">相机矩阵</a>的文章.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_camera_matrix</span>(<span class="params">renderer, data</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Returns the 3x4 camera matrix.&quot;&quot;&quot;</span></span><br><span class="line">  <span class="comment"># If the camera is a &#x27;free&#x27; camera, we get its position and orientation</span></span><br><span class="line">  <span class="comment"># from the scene data structure. It is a stereo camera, so we average over</span></span><br><span class="line">  <span class="comment"># the left and right channels. Note: we call `self.update()` in order to</span></span><br><span class="line">  <span class="comment"># ensure that the contents of `scene.camera` are correct.</span></span><br><span class="line">  renderer.update_scene(data)</span><br><span class="line">  pos = np.mean([camera.pos <span class="keyword">for</span> camera <span class="keyword">in</span> renderer.scene.camera], axis=<span class="number">0</span>)</span><br><span class="line">  z = -np.mean([camera.forward <span class="keyword">for</span> camera <span class="keyword">in</span> renderer.scene.camera], axis=<span class="number">0</span>)</span><br><span class="line">  y = np.mean([camera.up <span class="keyword">for</span> camera <span class="keyword">in</span> renderer.scene.camera], axis=<span class="number">0</span>)</span><br><span class="line">  rot = np.vstack((np.cross(y, z), y, z))</span><br><span class="line">  fov = model.vis.global_.fovy</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Translation matrix (4x4).</span></span><br><span class="line">  translation = np.eye(<span class="number">4</span>)</span><br><span class="line">  translation[<span class="number">0</span>:<span class="number">3</span>, <span class="number">3</span>] = -pos</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Rotation matrix (4x4).</span></span><br><span class="line">  rotation = np.eye(<span class="number">4</span>)</span><br><span class="line">  rotation[<span class="number">0</span>:<span class="number">3</span>, <span class="number">0</span>:<span class="number">3</span>] = rot</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Focal transformation matrix (3x4).</span></span><br><span class="line">  focal_scaling = (<span class="number">1.</span>/np.tan(np.deg2rad(fov)/<span class="number">2</span>)) * renderer.height / <span class="number">2.0</span></span><br><span class="line">  focal = np.diag([-focal_scaling, focal_scaling, <span class="number">1.0</span>, <span class="number">0</span>])[<span class="number">0</span>:<span class="number">3</span>, :]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Image matrix (3x3).</span></span><br><span class="line">  image = np.eye(<span class="number">3</span>)</span><br><span class="line">  image[<span class="number">0</span>, <span class="number">2</span>] = (renderer.width - <span class="number">1</span>) / <span class="number">2.0</span></span><br><span class="line">  image[<span class="number">1</span>, <span class="number">2</span>] = (renderer.height - <span class="number">1</span>) / <span class="number">2.0</span></span><br><span class="line">  <span class="keyword">return</span> image @ focal @ rotation @ translation</span><br></pre></td></tr></table></figure><p>让我们使用相机矩阵从世界坐标投影到相机坐标:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reset the scene</span></span><br><span class="line">renderer.update_scene(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the world coordinates of the box corners</span></span><br><span class="line">box_pos = data.geom_xpos[model.geom(<span class="string">&#x27;red_box&#x27;</span>).<span class="built_in">id</span>]</span><br><span class="line">box_mat = data.geom_xmat[model.geom(<span class="string">&#x27;red_box&#x27;</span>).<span class="built_in">id</span>].reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">box_size = model.geom_size[model.geom(<span class="string">&#x27;red_box&#x27;</span>).<span class="built_in">id</span>]</span><br><span class="line">offsets = np.array([-<span class="number">1</span>, <span class="number">1</span>]) * box_size[:, <span class="literal">None</span>]</span><br><span class="line">xyz_local = np.stack(<span class="built_in">list</span>(itertools.product(*offsets))).T</span><br><span class="line">xyz_global = box_pos[:, <span class="literal">None</span>] + box_mat @ xyz_local</span><br><span class="line"></span><br><span class="line"><span class="comment"># Camera matrices multiply homogenous [x, y, z, 1] vectors.</span></span><br><span class="line">corners_homogeneous = np.ones((<span class="number">4</span>, xyz_global.shape[<span class="number">1</span>]), dtype=<span class="built_in">float</span>)</span><br><span class="line">corners_homogeneous[:<span class="number">3</span>, :] = xyz_global</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the camera matrix.</span></span><br><span class="line">m = compute_camera_matrix(renderer, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Project world coordinates into pixel space. See:</span></span><br><span class="line"><span class="comment"># https://en.wikipedia.org/wiki/3D_projection#Mathematical_formula</span></span><br><span class="line">xs, ys, s = m @ corners_homogeneous</span><br><span class="line"><span class="comment"># x and y are in the pixel coordinate system.</span></span><br><span class="line">x = xs / s</span><br><span class="line">y = ys / s</span><br><span class="line"></span><br><span class="line"><span class="comment"># Render the camera view and overlay the projected corner coordinates.</span></span><br><span class="line">pixels = renderer.render()</span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.imshow(pixels)</span><br><span class="line">ax.plot(x, y, <span class="string">&#x27;+&#x27;</span>, c=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ax.set_axis_off()</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2023/04/13/mujoco-tutorial/18.png" class="" title="projection"></div><h3 id="修改场景"><a href="#修改场景" class="headerlink" title="修改场景"></a><strong>修改场景</strong></h3><p>让我们在 <code>mjvScene</code> 中添加一些任意的几何图形.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_geom_speed</span>(<span class="params">model, data, geom_name</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Returns the speed of a geom.&quot;&quot;&quot;</span></span><br><span class="line">  geom_vel = np.zeros(<span class="number">6</span>)</span><br><span class="line">  geom_type = mujoco.mjtObj.mjOBJ_GEOM</span><br><span class="line">  geom_id = data.geom(geom_name).<span class="built_in">id</span></span><br><span class="line">  mujoco.mj_objectVelocity(model, data, geom_type, geom_id, geom_vel, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> np.linalg.norm(geom_vel)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_visual_capsule</span>(<span class="params">scene, point1, point2, radius, rgba</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Adds one capsule to an mjvScene.&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">if</span> scene.ngeom &gt;= scene.maxgeom:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  scene.ngeom += <span class="number">1</span>  <span class="comment"># increment ngeom</span></span><br><span class="line">  <span class="comment"># initialise a new capsule, add it to the scene using mjv_makeConnector</span></span><br><span class="line">  mujoco.mjv_initGeom(scene.geoms[scene.ngeom-<span class="number">1</span>],</span><br><span class="line">                      mujoco.mjtGeom.mjGEOM_CAPSULE, np.zeros(<span class="number">3</span>),</span><br><span class="line">                      np.zeros(<span class="number">3</span>), np.zeros(<span class="number">9</span>), rgba.astype(np.float32))</span><br><span class="line">  mujoco.mjv_makeConnector(scene.geoms[scene.ngeom-<span class="number">1</span>],</span><br><span class="line">                           mujoco.mjtGeom.mjGEOM_CAPSULE, radius,</span><br><span class="line">                           point1[<span class="number">0</span>], point1[<span class="number">1</span>], point1[<span class="number">2</span>],</span><br><span class="line">                           point2[<span class="number">0</span>], point2[<span class="number">1</span>], point2[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"> <span class="comment"># traces of time, position and speed</span></span><br><span class="line">times = []</span><br><span class="line">positions = []</span><br><span class="line">speeds = []</span><br><span class="line">offset = model.jnt_axis[<span class="number">0</span>]/<span class="number">8</span>  <span class="comment"># offset along the joint axis</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_scene</span>(<span class="params">scn</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Draw position trace, speed modifies width and colors.&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(positions) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(positions)-<span class="number">1</span>):</span><br><span class="line">      rgba=np.array((np.clip(speeds[i]/<span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">                     np.clip(<span class="number">1</span>-speeds[i]/<span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">                     <span class="number">.5</span>, <span class="number">1.</span>))</span><br><span class="line">      radius=<span class="number">.003</span>*(<span class="number">1</span>+speeds[i])</span><br><span class="line">      point1 = positions[i] + offset*times[i]</span><br><span class="line">      point2 = positions[i+<span class="number">1</span>] + offset*times[i+<span class="number">1</span>]</span><br><span class="line">      add_visual_capsule(scn, point1, point2, radius, rgba)</span><br><span class="line"></span><br><span class="line">duration = <span class="number">6</span>    <span class="comment"># (seconds)</span></span><br><span class="line">framerate = <span class="number">30</span>  <span class="comment"># (Hz)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Simulate and display video.</span></span><br><span class="line">frames = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reset state and time.</span></span><br><span class="line">mujoco.mj_resetData(model, data)</span><br><span class="line">mujoco.mj_forward(model, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> data.time &lt; duration:</span><br><span class="line">  <span class="comment"># append data to the traces</span></span><br><span class="line">  positions.append(data.geom_xpos[data.geom(<span class="string">&quot;green_sphere&quot;</span>).<span class="built_in">id</span>].copy())</span><br><span class="line">  times.append(data.time)</span><br><span class="line">  speeds.append(get_geom_speed(model, data, <span class="string">&quot;green_sphere&quot;</span>))</span><br><span class="line">  mujoco.mj_step(model, data)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(frames) &lt; data.time * framerate:</span><br><span class="line">    renderer.update_scene(data)</span><br><span class="line">    modify_scene(renderer.scene)</span><br><span class="line">    pixels = renderer.render()</span><br><span class="line">    frames.append(pixels)</span><br><span class="line">media.show_video(frames, fps=framerate)</span><br></pre></td></tr></table></figure><video controls >     <source src="mjvScene.mp4" type="video/mp4"></video>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;center&quot;&gt;本文为 MuJoCo 官方教程的简单翻译. &lt;/div&gt;</summary>
    
    
    
    
    <category term="mujoco" scheme="http://shawshai.cn/tags/mujoco/"/>
    
  </entry>
  
  <entry>
    <title>Windows10 与子系统 Linux Ubuntu 的文件访问</title>
    <link href="http://shawshai.cn/2022/03/13/win2sublinux/"/>
    <id>http://shawshai.cn/2022/03/13/win2sublinux/</id>
    <published>2022-03-13T02:37:12.000Z</published>
    <updated>2022-03-13T05:22:43.269Z</updated>
    
    <content type="html"><![CDATA[<div align="center" style="width:70%; margin:auto">Win10 与子系统 Ubuntu 的文件互访</div><span id="more"></span><p>Windows10 出了子系统 Linux Ubuntu，喜大普奔的好消息。</p><p>Win10 系统可以通过 Microsoft Store 安装子系统 Ubuntu 18.04 LTS，二者是两个互相独立的系统。而子系统 Ubuntu 由于依托于主系统 Windows，其全部文件一定能在主系统 Windows 中找到。</p><p>首先附上参考链接：</p><blockquote><p>Win10 与 子系统 Ubuntu 之间互访文件系统</p><p><a href="https://www.jianshu.com/p/27a2f62fda5f">https://www.jianshu.com/p/27a2f62fda5f</a></p></blockquote><h1 id="在-Win10-中访问子系统-Ubuntu-中的文件"><a href="#在-Win10-中访问子系统-Ubuntu-中的文件" class="headerlink" title="在 Win10 中访问子系统 Ubuntu 中的文件"></a>在 Win10 中访问子系统 Ubuntu 中的文件</h1><p>子系统 Ubuntu 在 Win10 中的 home 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Win10用户名\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\rootfs\home</span><br></pre></td></tr></table></figure><p>子系统 Ubuntu 在 Win10 中的根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Win10用户名\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\rootfs\root</span><br></pre></td></tr></table></figure><h1 id="在子系统-Ubuntu-中访问-Win10-中的文件"><a href="#在子系统-Ubuntu-中访问-Win10-中的文件" class="headerlink" title="在子系统 Ubuntu 中访问 Win10 中的文件"></a>在子系统 Ubuntu 中访问 Win10 中的文件</h1><p>在子系统 Ubuntu 中，Win10 的硬盘分区均在 <code>\mnt</code> 目录下。</p><p>Ubuntu 中访问 Win10 的 home 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/c/Users/Win10用户名</span><br></pre></td></tr></table></figure><p>Ubuntu 中访问 Win10 的 e 盘目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/e</span><br></pre></td></tr></table></figure><h1 id="实现系统间文件互传"><a href="#实现系统间文件互传" class="headerlink" title="实现系统间文件互传"></a>实现系统间文件互传</h1><p>显然，两个系统间的文件互传，根本不需要任何特殊方法。</p><p>在 Win10 中找到子系统文件所在目录，直接对文件（夹）复制粘贴即可。</p><p>在子系统 Ubuntu 中也可以进行同样的操作。</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;center&quot; style=&quot;width:70%; margin:auto&quot;&gt;Win10 与子系统 Ubuntu 的文件互访&lt;/div&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://shawshai.cn/tags/Windows/"/>
    
    <category term="Ubuntu" scheme="http://shawshai.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>MOCAP动作捕获数据集</title>
    <link href="http://shawshai.cn/2021/09/24/mocap-data/"/>
    <id>http://shawshai.cn/2021/09/24/mocap-data/</id>
    <published>2021-09-24T05:42:27.000Z</published>
    <updated>2021-09-26T02:28:10.602Z</updated>
    
    <content type="html"><![CDATA[<div align="center">MOCAP</div><span id="more"></span><h2 id="动捕数据集"><a href="#动捕数据集" class="headerlink" title="动捕数据集"></a>动捕数据集</h2><ul><li><a href="http://mocap.cs.cmu.edu/">CMU运动捕捉数据库</a></li><li><a href="http://resources.mpi-inf.mpg.de/HDM05/">HDM05数据库</a></li></ul><h2 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h2><ul><li><a href="https://research.cs.wisc.edu/graphics/Courses/cs-838-1999/Jeff/ASF-AMC.html">ASF/AMC</a> （骨架数据文件（ASF）和运动数据文件（AMC））</li><li><a href="https://research.cs.wisc.edu/graphics/Courses/cs-838-1999/Jeff/BVH.html">BVH</a> （HIERARCHY描述运动的骨架层次和运动的初始状态，MOTION部分为运动数据）</li><li><a href="https://www.c3d.org/pdf/c3dformat_ug.pdf">C3D</a> （运动3D数据）</li></ul><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><ul><li><a href="http://mocap.cs.cmu.edu/tools.php">CMUTools</a></li><li><a href="http://mocap.cs.cmu.edu/resources.php">CMUResources</a></li><li><a href="https://alinen.github.io/MotionScriptTools/index.html">MotionScriptTools</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;center&quot;&gt;MOCAP&lt;/div&gt;</summary>
    
    
    
    
    <category term="mocap" scheme="http://shawshai.cn/tags/mocap/"/>
    
    <category term="cmu" scheme="http://shawshai.cn/tags/cmu/"/>
    
  </entry>
  
  <entry>
    <title>Neper 安装与配置过程</title>
    <link href="http://shawshai.cn/2021/06/08/neper/"/>
    <id>http://shawshai.cn/2021/06/08/neper/</id>
    <published>2021-06-08T05:31:25.000Z</published>
    <updated>2021-06-08T14:31:08.174Z</updated>
    
    <content type="html"><![CDATA[<div style="width:70%; margin:auto"><img src="/2021/06/08/neper/gene_gene-min.png" class="" title="neper"></div><span id="more"></span><p>Neper <a href="https://neper.info/">官网</a>。</p><p>首先附上<a href="https://pencilq.com/22/">参考链接</a>：</p><blockquote><p>安装 neper 多晶体网格生成软件</p><p><a href="https://pencilq.com/22/">https://pencilq.com/22/</a></p><p>Ubuntu20.04系统成功安装Neper多晶体网格生成软件记录</p><p><a href="https://geomatlab.com/neper-install/">https://geomatlab.com/neper-install/</a></p></blockquote><p>参考了其中WSL环境的安装步骤。</p><blockquote><p>系统：</p><p>Win10 (1809 以上) 的 Linux ubuntu 子系统 (WSL)  -  [Ubuntu 18.04]</p><p>所需组件：</p><p>gcc, g++; cmake; gsl; nlopt; povray; gmsh; imagemagick</p></blockquote><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>安装组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake</span><br><span class="line">sudo apt install g++</span><br><span class="line">sudo apt install gcc</span><br><span class="line">sudo apt-get install libnlopt.dev</span><br><span class="line">sudo apt-get install povray</span><br><span class="line">sudo apt-get install libgmsh-dev</span><br><span class="line">sudo apt-get install imagemagick</span><br></pre></td></tr></table></figure><p>安装GSL（此处参考<a href="https://www.cnblogs.com/nju2014/p/5334928.html">该链接</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgsl0-dev</span><br></pre></td></tr></table></figure><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><p>参考官方文档 Neper Reference Manual.</p><p>下载neper，时间较长。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/rquey/neper.git</span><br></pre></td></tr></table></figure><p>进入<code>neper/src/</code>目录，执行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> buid &amp;&amp; cmake ..</span><br><span class="line">make -j</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>继续在<code>build</code>目录下执行测试，可以在该目录下找到相应的生成文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h1 id="运行例子"><a href="#运行例子" class="headerlink" title="运行例子"></a>运行例子</h1><p>保存以下例子为 <code>gene_gene.sh</code>，执行 <code>sudo sh ./gene_gene.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NEPER=<span class="string">&quot;neper --rcfile none&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$NEPER</span> -T -n 1000 -domain <span class="string">&quot;cube(1,1,1)&quot;</span>       -o gene_gene_1</span><br><span class="line"><span class="variable">$NEPER</span> -T -n 1000 -domain <span class="string">&quot;cylinder(1,1,200)&quot;</span> -o gene_gene_2</span><br><span class="line"><span class="variable">$NEPER</span> -T -n 1000 -domain <span class="string">&quot;sphere(1,1000)&quot;</span>    -o gene_gene_3</span><br><span class="line"></span><br><span class="line">C=<span class="string">&quot;-datacellcol id -datacelltrs 0.5 -cameraangle 12 -imagesize 600:600&quot;</span></span><br><span class="line"><span class="variable">$NEPER</span> -V gene_gene_1.tess <span class="variable">$C</span> -<span class="built_in">print</span> gene_gene_1</span><br><span class="line"><span class="variable">$NEPER</span> -V gene_gene_2.tess <span class="variable">$C</span> -showedge <span class="string">&quot;cyl==0&quot;</span>   -cameraangle 11 -<span class="built_in">print</span> gene_gene_2</span><br><span class="line"><span class="variable">$NEPER</span> -V gene_gene_3.tess <span class="variable">$C</span> -showedge <span class="string">&quot;polynb&gt;1&quot;</span> -cameraangle 9 -<span class="built_in">print</span> gene_gene_3</span><br><span class="line"></span><br><span class="line">convert +append gene_gene_?.png gene_gene.png</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>生成的结果为最开始的图片。</p><p>另外按<a href="https://neper.info/generation.html">文档</a>中的例子导出一个可查看的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制示例网格并生成 tess_1.tess 文件</span></span><br><span class="line">neper -T -n 10 -morpho graingrowth -o tess_1</span><br><span class="line"><span class="comment"># 使用可视化模块生成图片 image_1.png</span></span><br><span class="line">neper -V  tess_1.tess -datacellcol id -<span class="built_in">print</span> image_1</span><br><span class="line"><span class="comment"># 将导出文件格式改为Gmsh格式，导出为 gmsh_1.geo 文件</span></span><br><span class="line">neper -T -n 10 -morpho graingrowth -o gmsh_1 -format geo</span><br></pre></td></tr></table></figure><p>详细参数见官方文档<a href="https://neper.info/docs/neper.pdf">Neper Reference Manual</a>。</p><div style="width:70%;margin:auto"><img src="/2021/06/08/neper/neper-save.png" class="" title="output_options"></div><p>此时文件夹下新生成了 <code>tess_1.tess</code>, <code>image_1.png</code>, <code>gmsh_1.geo</code> 三个文件。</p><div style="width:50%;margin:auto"><img src="/2021/06/08/neper/image_1.png" class="" title="image_1.png"></div><p>安装Gmsh之后，可查看<code>.geo</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gmsh gmsh_1.geo</span><br></pre></td></tr></table></figure><div style="width:50%;margin:auto"><img src="/2021/06/08/neper/gmsh_1.png" class="" title="gmsh_1.geo"></div><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="在Win10中配置WSL"><a href="#在Win10中配置WSL" class="headerlink" title="在Win10中配置WSL"></a>在Win10中配置WSL</h2><p>开始菜单右键 =&gt;  应用和功能 =&gt; 程序和功能（在右侧） =&gt; 启动或关闭Windows功能 =&gt; 适用于Linux的Windows子系统。打勾，确定，重启。</p><p>打开微软应用商店，搜索Ubuntu，选择一个Ubuntu系统安装即可。</p><p>WSL可视化。<a href="https://wu-kan.cn/2018/12/14/Windows-Subsystem-for-Linux/">参考链接</a>。</p><ol><li><p>在Windows中安装<a href="https://sourceforge.net/projects/vcxsrv/">VcXsrv</a>，一路默认下一步即可。完成后打开<code>XLaunch</code>，一路默认下一步。</p></li><li><p>在Ubuntu bash中，运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export DISPLAY=:0.0&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></li></ol><p>Done!</p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;width:70%; margin:auto&quot;&gt;&lt;img src=&quot;/2021/06/08/neper/gene_gene-min.png&quot; class=&quot;&quot; title=&quot;neper&quot;&gt;&lt;/div&gt;</summary>
    
    
    
    
    <category term="Neper" scheme="http://shawshai.cn/tags/Neper/"/>
    
    <category term="有限元" scheme="http://shawshai.cn/tags/%E6%9C%89%E9%99%90%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>Qt 环境配置</title>
    <link href="http://shawshai.cn/2021/05/07/qt-env-config/"/>
    <id>http://shawshai.cn/2021/05/07/qt-env-config/</id>
    <published>2021-05-07T04:19:31.000Z</published>
    <updated>2021-06-08T12:28:13.384Z</updated>
    
    <content type="html"><![CDATA[<div align="center">配置Qt+VS环境。</div><span id="more"></span><h1 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h1><p>Qt4选择最后一个版本4.8.7。搭配VS2010。</p><p>Qt5从5.15开始收费，且只能在线安装，于是选择5.14.2版本。搭配VS2019。</p><h1 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h1><ul><li><p>Qt4</p><p><a href="https://download.qt.io/archive/qt/4.8/4.8.7/qt-opensource-windows-x86-vs2010-4.8.7.exe">qt-opensource-windows-x86-vs2010-4.8.7.exe</a></p><p><a href="https://download.qt.io/archive/vsaddin/1.1.11/qt-vs-addin-1.1.11-opensource.exe">qt-vs-addin-1.1.11-opensource.exe</a></p></li><li><p>Qt5</p><p><a href="https://download.qt.io/archive/qt/5.14/5.14.2/qt-opensource-windows-x86-5.14.2.exe">qt-opensource-windows-x86-5.14.2.exe</a></p><p><a href="https://download.qt.io/archive/vsaddin/2.7.1/qt-vsaddin-msvc2019-2.7.1.vsix">qt-vsaddin-msvc2019-2.7.1.vsix</a>（可从VS2019扩展中搜索下载）</p></li></ul><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>先安装VS。</p><p>Qt 4.8.7直接下一步即可。</p><p>Qt 5.14.2 选择组件 MSVC 2017 32-bit 和MSVC 2017 64-bit。</p><p>Qt 允许用户自定义安装路径，但是请注意，安装路径不能带空格、中文字符或者其它任何特殊字符。</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;center&quot;&gt;配置Qt+VS环境。&lt;/div&gt;</summary>
    
    
    
    
    <category term="Qt" scheme="http://shawshai.cn/tags/Qt/"/>
    
    <category term="VS" scheme="http://shawshai.cn/tags/VS/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建过程</title>
    <link href="http://shawshai.cn/2021/04/24/hexo-github-study/"/>
    <id>http://shawshai.cn/2021/04/24/hexo-github-study/</id>
    <published>2021-04-24T13:38:19.000Z</published>
    <updated>2023-04-13T14:54:23.856Z</updated>
    
    <content type="html"><![CDATA[<div align = "center">记录博客网站的搭建过程。</div><span id="more"></span><h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>本博客网站的搭建，主要由以下三部分构成：</p><ul><li>Hexo静态博客框架；</li><li>GitHub托管静态网页；</li><li>阿里云域名购买。</li></ul><p>主要参考了知乎大佬的这篇教程：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GitHub+Hexo 搭建个人网站详细教程</span><br><span class="line">https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">26625249</span></span><br></pre></td></tr></table></figure><p>搭建过程完全按照教程进行。其中须注意的几点：</p><ol><li><p>GitHub创建新仓库托管静态网页，仓库类型必须为public；</p></li><li><p><code>hexo init blog</code>命令后，会新建一个blog文件夹，后面的命令均在新建的blog文件夹下执行；</p></li><li><p>域名解析和教程中稍有差异；</p><div style="width:50%;margin:auto"><img src="/2021/04/24/hexo-github-study/dns.jpg" class="" title="域名解析"></div></li><li><p>更换主题时要先将主题下载到themes文件夹中，next主题地址有更新；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li></ol><p>关于主题的个性化设置暂时还没有做。</p><h1 id="异地管理"><a href="#异地管理" class="headerlink" title="异地管理"></a>异地管理</h1><p>接下来将遇到异地管理问题（比如换了一台电脑）。注意到，在以上过程中托管到GitHub的文件，仅为所发布的网页文件，并非本地的编辑与配置源文件。因此还需要建立仓库来管理源文件。</p><p>于是找到这篇教程：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hexo+github个人博客搭建+异地管理</span><br><span class="line">https:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/zwx2445205419/</span>article<span class="regexp">/details/</span><span class="number">66970640</span></span><br></pre></td></tr></table></figure><p>其做法是在原仓库新建hexo分支，用于提交源文件。</p><p>考虑到原仓库为public，而我希望源文件为private，因此须建立private仓库。大致步骤如下:</p><ol><li><p>新建仓库名为hexo，设为private；（此处我擅自将分支也改名为hexo）</p></li><li><p>在blog文件夹外，将库hexo克隆到本地；（注意public和private库的克隆方式有所区别）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将https:// 改为 git@github.com:用户名/项目名称</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:shawshai/hexo.git</span><br></pre></td></tr></table></figure></li><li><p>将文件夹blog中所有文件复制到文件夹hexo中，并删除文件<code>.gitignore</code>；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo</span><br><span class="line"><span class="comment"># 添加所有变化，工作区-&gt;暂存区</span></span><br><span class="line">git add -A</span><br><span class="line"><span class="comment"># 暂存区-&gt;版本库</span></span><br><span class="line">git commit -m <span class="string">&quot;add all hexo files&quot;</span></span><br><span class="line"><span class="comment"># 本地库-&gt;远程库</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></li><li><p>此处发现主题文件夹next由于是从GitHub克隆，自动作为子模块，无法正常push到远程仓库hexo，须增加以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除Git文件</span></span><br><span class="line">rm -r themes/next/.git*</span><br><span class="line"><span class="comment"># 逆初始化模块</span></span><br><span class="line">git submodule deinit themes/next</span><br><span class="line"><span class="comment"># 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）</span></span><br><span class="line">git rm --cached themes/next </span><br><span class="line"><span class="comment"># 提交更改到代码库</span></span><br><span class="line">git commit -am <span class="string">&quot;Remove next submodule.&quot;</span> </span><br></pre></td></tr></table></figure><p>再重复步骤3，Done！</p></li></ol><p>更换电脑后，只要克隆hexo到本地，安装好<code>Node.js</code>和<code>Hexo</code>，在文件夹hexo中继续编辑即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装Node.js----[https://nodejs.org/en/download/]</span></span><br><span class="line"><span class="comment"># 检测是否安装成功</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"><span class="comment"># 安装Hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="comment"># 安装Git部署插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>注意，不需要<code>hexo init</code>，该操作会重置文件<code>_config.yml</code>中的参数。编辑结束后，依旧在当前目录hexo中，<code>hexo</code>部署，<code>git</code>上传即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">hexo g     <span class="comment"># 生成</span></span><br><span class="line">hexo s     <span class="comment"># 启动服务预览</span></span><br><span class="line">hexo d     <span class="comment"># 部署</span></span><br></pre></td></tr></table></figure><h1 id="添加评论系统-Gitalk"><a href="#添加评论系统-Gitalk" class="headerlink" title="添加评论系统-Gitalk"></a>添加评论系统-Gitalk</h1><p>博客评论系统选择了Gitalk，具体参考了以下<a href="https://www.toimc.com/hexo-usage-3/">链接</a>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo主题<span class="keyword">next</span>中gitalk配置与评论初始化</span><br><span class="line">https:<span class="regexp">//</span>www.toimc.com<span class="regexp">/hexo-usage-3/</span></span><br></pre></td></tr></table></figure><p>只进行到 <code>安装npm依赖项</code>。</p><p>另外，也参考了<a href="https://nonlinearthink.github.io/hexo/hexo-gitalk/">这篇</a>的说明。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>后续将继续记录使用过程中遇到的问题，以及解决办法。</p><h2 id="插入图片问题"><a href="#插入图片问题" class="headerlink" title="插入图片问题"></a>插入图片问题</h2><p>插入图片是基本需求。</p><p>参考了<a href="https://zhuanlan.zhihu.com/p/265077468">链接</a>，在文件夹hexo中的文件<code>_config.yml</code>中更改设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>安装插件<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><p>目前有两种方式插入本地图片：</p><ol><li><p>使用markdown语法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[图片信息描述]</span>(abc.jpg)</span><br></pre></td></tr></table></figure><p>此方法无法控制图片大小，默认占满父容器宽度。Typora中一旦设置图片缩放，便转化成了html语法，部署后图片路径出错，无法显示。</p></li><li><p>使用html语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:50%;margin:auto&quot;</span>&gt;</span>&#123;% asset_img abc.png 图片信息描述 %&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此方法在Typora中无法像显示图像，但能够实现调整网页中图像大小。</p><p>参考了以下链接：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hexo</span> 自定义图片大小</span><br><span class="line"><span class="attribute">https</span>://www.dazhuanlan.com/<span class="number">2019</span>/<span class="number">10</span>/<span class="number">07</span>/<span class="number">5</span>d<span class="number">9</span>a<span class="number">759</span>c<span class="number">66188</span>/</span><br></pre></td></tr></table></figure></li></ol><p>还是希望能够调整图片大小，因此目前采用了第二种方法。</p><h2 id="异地克隆问题"><a href="#异地克隆问题" class="headerlink" title="异地克隆问题"></a>异地克隆问题</h2><p>更换电脑时，将私有库hexo克隆到本地时，本地测试运行重启后页面空白，提示 : </p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN No <span class="keyword">layout</span>: <span class="keyword">index</span>.html</span><br></pre></td></tr></table></figure><p>检查发现远程私有库hexo中主题文件夹themes\next是空的，没有push上去。</p><p>重新克隆主题next即可。完整过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:shawshai/hexo.git</span><br><span class="line"><span class="built_in">cd</span> hexo</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><hr><p>很快发现，上述方案并没有解决问题，因为新克隆的主题next参数配置全部为初始值。</p><p>主题文件next无法<code>push</code>的原因：该主题是从Github克隆的，自动作为hexo的子模块。</p><p>正确解决方案如下：</p><p>先删除其Git文件，然后删除其子模块身份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除Git文件</span></span><br><span class="line">rm -r themes/next/.git*</span><br><span class="line"><span class="comment"># 逆初始化模块</span></span><br><span class="line">git submodule deinit themes/next</span><br><span class="line"><span class="comment"># 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）</span></span><br><span class="line">git rm --cached themes/next </span><br><span class="line"><span class="comment"># 提交更改到代码库</span></span><br><span class="line">git commit -am <span class="string">&quot;Remove a submodule.&quot;</span> </span><br></pre></td></tr></table></figure><p>如此，主题文件next便能正常push，后续将不会遭遇此问题。（已补充到第2节异地管理第4步中）</p><p>Done.</p><h2 id="还是Git问题"><a href="#还是Git问题" class="headerlink" title="还是Git问题"></a>还是Git问题</h2><p>由于时常需要在笔记本和台式机之间切换，在使用Git时遇到一点问题。</p><p>目前的策略是，在一端编辑完成，最后一次<code>hexo d</code>之后，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;修改说明&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>然后在另一端，开始编辑前，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>每次编辑始于<code>git pull</code>，终于<code>git push</code>，仓库hexo中只设一个分支，最大程度避免在Git中遇到复杂情况。</p><p>然而，这个流程存在问题：有时执行<code>git pull</code>后发现拉取的文件不全，远程库中某些文件没有更新到本地。</p><p>这是由于本地内容有更改，所以没有<code>pull</code>成功。添加以下命令实测有效：（<a href="https://www.cnblogs.com/tocy/p/git-stash-reference.html">参考链接</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash<span class="comment"># 储存本地修改</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>Done.</p><h2 id="LaTeX支持"><a href="#LaTeX支持" class="headerlink" title="LaTeX支持"></a>LaTeX支持</h2><p>数学公式的显示是必需的。配置<a href="https://xu-jinzhong.gitee.io/2020/03/17/maths-formula-display/">参考链接</a>如下：</p><blockquote><p>数学公式显示</p><p><a href="https://xu-jinzhong.gitee.io/2020/03/17/maths-formula-display/">https://xu-jinzhong.gitee.io/2020/03/17/maths-formula-display/</a></p></blockquote><h3 id="开启mathjax"><a href="#开启mathjax" class="headerlink" title="开启mathjax"></a>开启mathjax</h3><p>进入目录 <strong>~\themes\next</strong>，编辑 <strong>_config.yml</strong> ，修改如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="新建博客添加mathjax"><a href="#新建博客添加mathjax" class="headerlink" title="新建博客添加mathjax"></a>新建博客添加mathjax</h3><p>在带有公式的博客开头添加 <strong>mathjax:true</strong> 即可，类似如下内容</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Hello, World!</span><br><span class="line">date: 2021<span class="string">-04</span><span class="string">-24</span> 21:34:56</span><br><span class="line"><span class="keyword">tags:</span> hello</span><br><span class="line">mathjax: true</span><br><span class="line">typora-root-url: hello-world</span><br></pre></td></tr></table></figure><p>done!</p><h2 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h2><p>要在博客中插入视频文件，需要知道如何在HTML中插入视频。</p><p>参考了文章“<a href="https://www.w3cschool.cn/article/52607231.html">HTML怎么添加视频？附三种方法！</a>”中的方法一：</p><p><code>&lt;video&gt;&lt;/video&gt;</code>标签是 HTML5 的一个新特性，它用于在 HTML 页面嵌入视频元素。具体使用方法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> &gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;视频路径&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/视频格式&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只需要把视频文件放在markdown文件对应的资源文件夹中，然后将上面的“视频路径”替换为视频文件名即可。例如要添加的视频为 <code>hello.mp4</code> ，只需将其放入资源文件夹，然后</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> &gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;hello.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即可。非常方便。</p><p>另外，Typora中也可以通过这种方法插入视频。</p>]]></content>
    
    
    <summary type="html">&lt;div align = &quot;center&quot;&gt;记录博客网站的搭建过程。&lt;/div&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="http://shawshai.cn/tags/hexo/"/>
    
    <category term="github" scheme="http://shawshai.cn/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hello, World!</title>
    <link href="http://shawshai.cn/2021/04/24/hello-world/"/>
    <id>http://shawshai.cn/2021/04/24/hello-world/</id>
    <published>2021-04-24T13:34:56.000Z</published>
    <updated>2021-09-26T02:28:10.602Z</updated>
    
    <content type="html"><![CDATA[<div align="center">欢迎来到少帥的博客~</div><span id="more"></span><p>测试 $\LaTeX$ 支持。</p><p>测试图片支持。</p><div style="width:40%; margin:auto"><img src="/2021/04/24/hello-world/erlu_300.png" class=""></div>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;center&quot;&gt;欢迎来到少帥的博客~&lt;/div&gt;</summary>
    
    
    
    
    <category term="hello" scheme="http://shawshai.cn/tags/hello/"/>
    
  </entry>
  
</feed>
